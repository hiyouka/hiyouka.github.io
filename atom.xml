<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hiyouka</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiyouka.top/"/>
  <updated>2019-02-15T02:11:10.218Z</updated>
  <id>https://hiyouka.top/</id>
  
  <author>
    <name>hiyouka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现spring的依赖注入</title>
    <link href="https://hiyouka.top/spring/ioc-create/"/>
    <id>https://hiyouka.top/spring/ioc-create/</id>
    <published>2019-01-29T01:13:00.000Z</published>
    <updated>2019-02-15T02:11:10.218Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006Xmmmgly1fzkw1qcnpqj30m80fzq89.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;以前用扫包和java自带的动态代理实现了简单的类似spring自动注入的功能。通过半年的学习想要再次实现这样的功能并更贴近spring的<code>@Autowired</code>注解的设计,希望看到的小伙伴能有所收获。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006Xmmmgly1fzkw1qcnpqj30m80fzq89.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;以前用扫包和java自带的动态代理实现了简单的类似spring自动注入的功能。通过半年的学习想要再次实现这样的功能并更贴近spring的&lt;code&gt;@Autowired&lt;/code&gt;注解的设计,希望看到的小伙伴能有所收获。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
      <category term="proxy" scheme="https://hiyouka.top/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>自己实现一个可拓展的ioc容器</title>
    <link href="https://hiyouka.top/spring/ioc-autowired/"/>
    <id>https://hiyouka.top/spring/ioc-autowired/</id>
    <published>2019-01-28T11:19:00.000Z</published>
    <updated>2019-02-15T02:11:10.212Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006Xmmmgly1fzkwu9bq57j30xc0r4dlz.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;最近比较无聊研究了些spring的源码。于是想到了自己模仿spring写一个简单可扩展的ioc容器。希望能够帮到看到的小伙伴。博主的网站时刚搭建完成的还请小伙伴门多多关注。如果喜欢的话别忘了给博主的github项目点个star或者follow一波。(<em>^_^</em>)<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006Xmmmgly1fzkwu9bq57j30xc0r4dlz.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近比较无聊研究了些spring的源码。于是想到了自己模仿spring写一个简单可扩展的ioc容器。希望能够帮到看到的小伙伴。博主的网站时刚搭建完成的还请小伙伴门多多关注。如果喜欢的话别忘了给博主的github项目点个star或者follow一波。(&lt;em&gt;^_^&lt;/em&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器创建源码解析</title>
    <link href="https://hiyouka.top/spring/ioc-analysis/"/>
    <id>https://hiyouka.top/spring/ioc-analysis/</id>
    <published>2019-01-25T07:17:00.000Z</published>
    <updated>2019-02-15T02:11:10.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1g04jqooe91j30qo0dc7d2.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇博客是对Spring的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多(准备好瓜子和板凳😀)。希望喜欢的小伙伴给博主的<a href="https://github.com/hiyouka/spring-cloud-resources" title="github" target="_blank" rel="noopener">github</a>点个star或者follow一波(<em>^_^</em>)。<br><a id="more"></a></p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzoibf7gh5j30p60673yo.jpg" alt="img"></p><h3 id="无参构造器的调用："><a href="#无参构造器的调用：" class="headerlink" title="无参构造器的调用："></a>无参构造器的调用：</h3><p>&emsp;&emsp;先是调用它的无参构造函数，初始化一些信息。<br>&emsp;&emsp;无参构造函数中<code>new</code>了<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefiitionScanner</code>赋值给<code>reader</code>context的<code>scanner</code>属性。  </p><h4 id="newAnnotatedBeanDefinitionReader对象："><a href="#newAnnotatedBeanDefinitionReader对象：" class="headerlink" title="newAnnotatedBeanDefinitionReader对象："></a><code>new</code>AnnotatedBeanDefinitionReader对象：</h4><p>&emsp;&emsp;&emsp;&emsp;将该容器对象作为<code>BeanDefinitionRegistry</code>赋值给<code>registry</code>属性,并且<code>new</code>了一个<code>ConditionEvaluator</code>赋值给<code>conditionEvaluator</code>属性。之后调用<code>registerAnnotationConfigProcessors</code>方法将所有的annotation处理器注册进容器。  </p><h5 id="new-ConditionEvaluator"><a href="#new-ConditionEvaluator" class="headerlink" title="new ConditionEvaluator:"></a>new ConditionEvaluator:</h5><p>&emsp;&emsp;&emsp;&emsp;这是spring对该类的描述<code>Internal class used to evaluate {@link Conditional} annotations.</code>。可以看出这个类是<code>@Conditional</code>注解的一个解析器。在创建该类的时候利用<code>deduceBeanFactory</code>给该对象初始化了一个<code>DefaultListableBeanFactory</code>,并且该类是从容器中获取的。  </p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzojh47uzbj30ud05u74g.jpg" alt="img"></p><h5 id="AnnotationConfigUtils-registerAnnotationConfigProcessors："><a href="#AnnotationConfigUtils-registerAnnotationConfigProcessors：" class="headerlink" title="AnnotationConfigUtils.registerAnnotationConfigProcessors："></a>AnnotationConfigUtils.registerAnnotationConfigProcessors：</h5><p>&emsp;&emsp;&emsp;&emsp;该方法先是给容器的<code>beanFactory</code>初始化了<code>private Comparator&lt;Object&gt; dependencyComparator;</code>和<code>private AutowireCandidateResolver autowireCandidateResolver</code>两个属性；他们分别是用于bean的排序和解析自动注入<code>@Autowired</code>的；之后便开始注册一些spring内部的bean对象：<br><a name="divtop"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//spring检查容器中是否注入了这些bean 没有就创建简单的含有基本信息的BeanDefiintion对象注册</span></span><br><span class="line">   <span class="comment">// The bean name of the internally managed Configuration annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Autowired annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Required annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JSR-250 annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JPA annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME =</span><br><span class="line"><span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed @EventListener annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed EventListenerFactory.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_FACTORY_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册过程如下 详见DefaultListableBeanFactory的registerBeanDefinition</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">//do some thing .... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"> <span class="comment">// get beanDefinintion from cache</span></span><br><span class="line">oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">// if cache alredy has this beanName beanDefinition break</span></span><br><span class="line">    <span class="comment">//  some warn message or throw exception</span></span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// determine if create bean has started</span></span><br><span class="line"><span class="comment">//(判断方法很简单benaFactory中的Set&lt;String&gt;alreadyCreated是否已经被填充过)</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123; </span><br><span class="line">           <span class="comment">//lock beanDefinitionMap and put this beanDefinition to map</span></span><br><span class="line">           <span class="comment">//这里有个小细节他在添加元素进beanDefinitionNames时是直接创建了一个原先cache size+1的list</span></span><br><span class="line">           <span class="comment">//然后再将this beanDefinition name 放入list,最终改变beanDefinitionNames的为新创建list</span></span><br><span class="line">           <span class="comment">//if this beanDefinition is in manualSingletonNames,remove from list. why?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">this.beanDefinitionNames.add(beanName);</span><br><span class="line">this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">this.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果这个bean已经存在了单实例的对象则将其销毁</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&emsp;&emsp;至此<code>AnnotatedBeanDefinitionReaderd</code>对象创建完成  </p><h4 id="newClassPathBeanDefinitionScanner对象："><a href="#newClassPathBeanDefinitionScanner对象：" class="headerlink" title="newClassPathBeanDefinitionScanner对象："></a><code>new</code>ClassPathBeanDefinitionScanner对象：</h4><p>&emsp;&emsp;&emsp;&emsp;先是调用这个构造方法：  </p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzom0bqbtgj30ps07ddg0.jpg" alt="img"><br>&emsp;&emsp;&emsp;&emsp;这里可以看出有3步操作<code>registerDefaultFilters</code>,<code>setEnvironment</code>,<code>setResourceLoader</code>  </p><h5 id="registerDefaultFilters方法"><a href="#registerDefaultFilters方法" class="headerlink" title="registerDefaultFilters方法:"></a>registerDefaultFilters方法:</h5><p>&emsp;&emsp;&emsp;&emsp;从名字我们不难看出这是创建默认过滤器的方法；<br>&emsp;&emsp;&emsp;&emsp;实际上是往该对象中添加了一个匹配<code>@Component</code>注解的AnnotationTypeFilter。spring对该类的解释如下：<br>&emsp;&emsp;&emsp;&emsp;<code>A simple filter which matches classes with a given annotation,checking inherited annotations as well.</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="comment">//代码如下：</span></span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="setEnvironment方法"><a href="#setEnvironment方法" class="headerlink" title="setEnvironment方法:"></a>setEnvironment方法:</h5><p>&emsp;&emsp;&emsp;&emsp;一样看名字我们就能知道这是设置环境信息的。就是将之前创建<code>AnnotatedBeanDefinitionReader</code>对象时获取的<code>StandardEnvironment</code>设置给该对象的<code>environment</code>属性。  </p><h5 id="setResourceLoader方法"><a href="#setResourceLoader方法" class="headerlink" title="setResourceLoader方法:"></a>setResourceLoader方法:</h5><p>&emsp;&emsp;&emsp;&emsp;该方法分别给该对象的<code>resourcePatternResolver</code>,<code>metadataReaderFactory</code>,<code>componentsIndex</code>属性初始化。<code>resourcePatternResolver</code>对象其实就是容器对象…. <code>metadataReaderFactory</code>是一个从容器<code>resourceCaches</code>属性拷贝过来的<code>ConcurrentHashMap</code>。<code>resourcePatternResolver</code>可能是在加载<code>META-INF/spring.components</code>这个配置文件吧。具体我也不太清楚。<br>&emsp;&emsp;&emsp;&emsp;<strong>至此spring容器的无参构造函数终于时调用完成了(😓)这只是简单的一步而且很多地方即使是知道了它在干什么还是不清楚他为什么这么做如果有更了解的大佬还望指教</strong>  </p><h3 id="register方法调用："><a href="#register方法调用：" class="headerlink" title="register方法调用："></a>register方法调用：</h3><p>&emsp;&emsp;将Config类注册进来，其实就是调用之前创建的<code>AnnotatedBeanDefinitionReader</code>对象的<code>register</code>方法将我们所传入的配置类注册到容器当中。我们可以直接看<code>AnnotatedBeanDefinitionReader</code>对象的<code>doRegisterBean</code>方法：<br>&emsp;&emsp;该方法先是创建了Config对象的定义信息<code>AnnotatedGenericBeanDefinition</code>。之后调用以下方法<code>shouldSkip</code>,<code>resolveScopeMetadata</code>,<code>generateBeanName</code>,<code>processCommonDefinitionAnnotations</code>,<code>applyScopedProxyMode</code>,<code>registerBeanDefinition</code>  </p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzonkylu48j30y00guwfe.jpg" alt="img"></p><h4 id="shouldSkip方法："><a href="#shouldSkip方法：" class="headerlink" title="shouldSkip方法："></a>shouldSkip方法：</h4><p>&emsp;&emsp;&emsp;&emsp;该方法先通过<code>isAnnotated</code>判断有没有<code>@Conditional</code>注解如果有则判断该类是否符合注入要求。<br>&emsp;&emsp;&emsp;&emsp; 我们先来看下他是如何判断有没有该注解的：<br>&emsp;&emsp;&emsp;&emsp;首先是<code>searchWithGetSemantics</code>方法来查出该类所有注解。<code>searchWithGetSemanticsInAnnotations</code>来做判断。如果该注解不是java包中的注解。则判断它是否是<code>@Conditional</code>注解或者任何时候都忽略的process。之后递归调用<code>searchWithGetSemantics</code>来看元注解有没有包含<code>@Conditional</code>的。以下为判断源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">    Class&lt;? extends Annotation&gt; currentAnnotationType = annotation.annotationType();</span><br><span class="line"><span class="keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (currentAnnotationType == annotationType ||</span><br><span class="line">currentAnnotationType.getName().equals(annotationName) ||</span><br><span class="line">processor.alwaysProcesses()) &#123;</span><br><span class="line">T result = processor.process(element, annotation, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (processor.aggregates() &amp;&amp; metaDepth == <span class="number">0</span>) &#123;</span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Repeatable annotations in container?</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currentAnnotationType == containerType) &#123;</span><br><span class="line"><span class="keyword">for</span> (Annotation contained : getRawAnnotationsFromContainer(element, annotation)) &#123;</span><br><span class="line">T result = processor.process(element, contained, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No need to post-process since repeatable annotations within a</span></span><br><span class="line"><span class="comment">// container cannot be composed annotations.</span></span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="resolveScopeMetadata方法"><a href="#resolveScopeMetadata方法" class="headerlink" title="resolveScopeMetadata方法:"></a>resolveScopeMetadata方法:</h4><p>&emsp;&emsp;&emsp;&emsp;获取该bean的scope(这里就不细讲spring bean的作用域了不懂的自行百度),ScopeMetadata对象的值默认为<code>singleton</code>,所以如果该类没有<code>@Scope</code>注解默认为单例的。  </p><h4 id="generateBeanName方法"><a href="#generateBeanName方法" class="headerlink" title="generateBeanName方法:"></a>generateBeanName方法:</h4><p>&emsp;&emsp;&emsp;&emsp;获取该bean的<code>@Component</code>注解标注的beanName,如果没有默认为类sortName。<br>获取类上的<code>@Component</code>注解步骤与第一步时获取<code>@Conditional</code>注解类似(递归获取注解-排除java注解)这里就不细讲了。</p><h4 id="processCommonDefinitionAnnotations方法"><a href="#processCommonDefinitionAnnotations方法" class="headerlink" title="processCommonDefinitionAnnotations方法:"></a>processCommonDefinitionAnnotations方法:</h4><p> &emsp;&emsp;&emsp;&emsp;对<code>@Lazy</code>,<code>@Primary</code>,<code>@DependsOn</code>,<code>@Role</code>,<code>@Description</code>的解析(这里提一下如果<code>@Lazy</code>没有的话默认是false,之前看到有人说默认懒加载显然时不正确的~)。丰富beanDefinition。比较简单不详细分析了,贴下源码:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">if (lazy != null) &#123;</span><br><span class="line"><span class="code">    abd.setLazyInit(lazy.getBoolean("value"));</span></span><br><span class="line">&#125;</span><br><span class="line">else if (abd.getMetadata() != metadata) &#123;</span><br><span class="line"><span class="code">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span></span><br><span class="line"><span class="code">    if (lazy != null) &#123;</span></span><br><span class="line"><span class="code">        abd.setLazyInit(lazy.getBoolean("value"));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">if (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line"><span class="code">    abd.setPrimary(true);</span></span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">if (dependsOn != null) &#123;</span><br><span class="line"><span class="code">    abd.setDependsOn(dependsOn.getStringArray("value"));</span></span><br><span class="line">&#125;</span><br><span class="line">if (abd instanceof AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="code">    AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span></span><br><span class="line"><span class="code">    AnnotationAttributes role = attributesFor(metadata, Role.class);</span></span><br><span class="line"><span class="code">    if (role != null) &#123;</span></span><br><span class="line"><span class="code">        absBd.setRole(role.getNumber("value").intValue());</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    AnnotationAttributes description = attributesFor(metadata, Description.class);</span></span><br><span class="line"><span class="code">    if (description != null) &#123;</span></span><br><span class="line"><span class="code">        absBd.setDescription(description.getString("value"));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="applyScopedProxyMode方法"><a href="#applyScopedProxyMode方法" class="headerlink" title="applyScopedProxyMode方法:"></a>applyScopedProxyMode方法:</h4><p>&emsp;&emsp;&emsp;&emsp;判断是否需要创建代理对象。如果需要调用<code>ScopedProxyCreator.createScopedProxy</code>方法创建。(待补全代理对象的创建过程…)  </p><h4 id="registerBeanDefinition方法"><a href="#registerBeanDefinition方法" class="headerlink" title="registerBeanDefinition方法:"></a>registerBeanDefinition方法:</h4><p>&emsp;&emsp;&emsp;&emsp;从方法名可以看出这部是真正的注册beanDefinition。真正调用的是容器中的BeanFactory(这里是<code>DefaultListableBeanFactory</code>)的<code>registerBeanDefinition</code>方法。首先验证beanDefinition的信息(具体我也没看懂在干什么)。之后判断该beanDefinition是否被注册过(若注册过符合条件覆盖之前的beanDefinition)。之后就是第一次注册该bean的操作(和调用无参构造函数注册过程一致<a href="#divtop">详情</a>。)<br>&emsp;&emsp;&emsp;&emsp;  </p><p><strong><code>register</code>方法分析到这里就结束了，其实做的事情就是将配置类注册到容器当中。</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007BVBG7gy1g04jqooe91j30qo0dc7d2.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这篇博客是对Spring的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多(准备好瓜子和板凳😀)。希望喜欢的小伙伴给博主的&lt;a href=&quot;https://github.com/hiyouka/spring-cloud-resources&quot; title=&quot;github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;点个star或者follow一波(&lt;em&gt;^_^&lt;/em&gt;)。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>多线程事务问题的记录</title>
    <link href="https://hiyouka.top/transaction/thread-save/"/>
    <id>https://hiyouka.top/transaction/thread-save/</id>
    <published>2019-01-23T01:13:00.000Z</published>
    <updated>2019-02-15T02:11:10.227Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006Xmmmgly1fzkw99da76j30e606fjrg.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006Xmmmgly1fzkw99da76j30e606fjrg.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
    
    </summary>
    
      <category term="事务" scheme="https://hiyouka.top/categories/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="多线程" scheme="https://hiyouka.top/categories/%E4%BA%8B%E5%8A%A1/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Transaction" scheme="https://hiyouka.top/tags/Transaction/"/>
    
      <category term="Thread" scheme="https://hiyouka.top/tags/Thread/"/>
    
  </entry>
  
</feed>
