<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hiyouka</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiyouka.top/"/>
  <updated>2019-02-13T01:48:09.909Z</updated>
  <id>https://hiyouka.top/</id>
  
  <author>
    <name>hiyouka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实现spring的依赖注入</title>
    <link href="https://hiyouka.top/spring/ioc-create/"/>
    <id>https://hiyouka.top/spring/ioc-create/</id>
    <published>2019-01-29T01:13:00.000Z</published>
    <updated>2019-02-13T01:48:09.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;以前用扫包和java自带的动态代理实现了简单的类似spring自动注入的功能。通过半年的学习想要再次实现这样的功能并更贴近spring的<code>@Autowired</code>注解的设计,希望看到的小伙伴能有所收获。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;以前用扫包和java自带的动态代理实现了简单的类似spring自动注入的功能。通过半年的学习想要再次实现这样的功能并更贴近spring的&lt;code&gt;@Autowired&lt;/code&gt;注解的设计,希望看到的小伙伴能有所收获。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
      <category term="proxy" scheme="https://hiyouka.top/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>自己实现一个可拓展的ioc容器</title>
    <link href="https://hiyouka.top/spring/ioc-autowired/"/>
    <id>https://hiyouka.top/spring/ioc-autowired/</id>
    <published>2019-01-28T11:19:00.000Z</published>
    <updated>2019-02-13T01:48:09.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;最近比较无聊研究了些spring的源码。于是想到了自己模仿spring写一个简单可扩展的ioc容器。希望能够帮到看到的小伙伴。博主的网站时刚搭建完成的还请小伙伴门多多关注。如果喜欢的话别忘了给博主的github项目点个star或者follow一波。(<em>^_^</em>)<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近比较无聊研究了些spring的源码。于是想到了自己模仿spring写一个简单可扩展的ioc容器。希望能够帮到看到的小伙伴。博主的网站时刚搭建完成的还请小伙伴门多多关注。如果喜欢的话别忘了给博主的github项目点个star或者follow一波。(&lt;em&gt;^_^&lt;/em&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器创建源码解析</title>
    <link href="https://hiyouka.top/spring/ioc-analysis/"/>
    <id>https://hiyouka.top/spring/ioc-analysis/</id>
    <published>2019-01-25T07:17:00.000Z</published>
    <updated>2019-02-13T01:48:09.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇博客完全是对Spring的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多(准备好瓜子和板凳😀)。希望喜欢的小伙伴给博主的<a href="https://github.com/hiyouka/spring-cloud-resources" title="github" target="_blank" rel="noopener">github</a>点个star或者follow一波(<em>^_^</em>)。<br><a id="more"></a></p><h2 id="AnnotationConfigApplocationContext创建过程"><a href="#AnnotationConfigApplocationContext创建过程" class="headerlink" title="AnnotationConfigApplocationContext创建过程:"></a>AnnotationConfigApplocationContext创建过程:</h2><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1g04jqooe91j30qo0dc7d2.jpg" alt="img"></p><h4 id="1-无参构造器的调用："><a href="#1-无参构造器的调用：" class="headerlink" title="1.无参构造器的调用："></a>1.无参构造器的调用：</h4><p>&emsp;&emsp;先是调用它的无参构造函数，初始化一些信息。<br>&emsp;&emsp;无参构造函数中<code>new</code>了<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefiitionScanner</code>赋值给<code>reader</code>context的<code>scanner</code>属性。<br>&emsp;&emsp;<strong><em>1)</em></strong> <code>new</code>AnnotatedBeanDefinitionReader对象：<br>&emsp;&emsp;&emsp;&emsp;将该容器对象作为<code>BeanDefinitionRegistry</code>赋值给<code>registry</code>属性,并且<code>new</code>了一个<code>ConditionEvaluator</code>赋值给<code>conditionEvaluator</code>属性。之后调用<code>registerAnnotationConfigProcessors</code>方法将所有的anntaton处理器注册进容器。<br>&emsp;&emsp;&emsp;&emsp;<strong>1-1</strong>) new ConditionEvaluator:<br>&emsp;&emsp;&emsp;&emsp;这是spring对该类的描述<code>Internal class used to evaluate {@link Conditional} annotations.</code>。可以看出这个类是<code>@Conditional</code>注解的一个解析器。在创建该类的时候利用<code>deduceBeanFactory</code>给该对象初始化了一个<code>DefaultListableBeanFactory</code>,并且该类是从容器中获取的。  </p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzojh47uzbj30ud05u74g.jpg" alt="img"><br>&emsp;&emsp;&emsp;&emsp;<strong>1-2</strong>) AnnotationConfigUtils.registerAnnotationConfigProcessors：<br>&emsp;&emsp;&emsp;&emsp;该方法先是给容器的<code>beanFactory</code>初始化了<code>private Comparator&lt;Object&gt; dependencyComparator;</code>和<code>private AutowireCandidateResolver autowireCandidateResolver</code>两个属性；他们分别是用于bean的排序和解析自动注入<code>@Autowired</code>的；之后便开始注册一些spring内部的bean对象：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//spring检查容器中是否注入了这些bean 没有就创建简单的含有基本信息的BeanDefiintion对象注册</span></span><br><span class="line">   <span class="comment">// The bean name of the internally managed Configuration annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Autowired annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Required annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JSR-250 annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JPA annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME =</span><br><span class="line"><span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed @EventListener annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed EventListenerFactory.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_FACTORY_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册过程如下 详见DefaultListableBeanFactory的registerBeanDefinition</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">//do some thing .... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"> <span class="comment">// get beanDefinintion from cache</span></span><br><span class="line">oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">// if cache alredy has this beanName beanDefinition break</span></span><br><span class="line">    <span class="comment">//  some warn message or throw exception</span></span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// determine if create bean has started</span></span><br><span class="line"><span class="comment">//(判断方法很简单benaFactory中的Set&lt;String&gt;alreadyCreated是否已经被填充过)</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123; </span><br><span class="line">           <span class="comment">//lock beanDefinitionMap and put this beanDefinition to map</span></span><br><span class="line">           <span class="comment">//这里有个小细节他在添加元素进beanDefinitionNames时是直接创建了一个原先cache size+1的list</span></span><br><span class="line">           <span class="comment">//然后再将this beanDefinition name 放入list,最终改变beanDefinitionNames的为新创建list</span></span><br><span class="line">           <span class="comment">//if this beanDefinition is in manualSingletonNames,remove from list. why?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">this.beanDefinitionNames.add(beanName);</span><br><span class="line">this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">this.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果这个bean已经存在了单实例的对象则将其销毁</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&emsp;&emsp;至此<code>AnnotatedBeanDefinitionReaderd</code>对象创建完成<br>&emsp;&emsp;<strong><em>2)</em></strong> <code>new</code>ClassPathBeanDefinitionScanner对象：<br>&emsp;&emsp;&emsp;&emsp;先是调用这个构造方法：  </p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzom0bqbtgj30ps07ddg0.jpg" alt="img"><br>&emsp;&emsp;&emsp;&emsp;这里可以看出有3步操作<code>registerDefaultFilters</code>,<code>setEnvironment</code>,<code>setResourceLoader</code><br>&emsp;&emsp;&emsp;&emsp;<strong>2-1</strong>) registerDefaultFilters方法:<br>&emsp;&emsp;&emsp;&emsp;从名字我们不难看出这是创建默认过滤器的方法；<br>&emsp;&emsp;&emsp;&emsp;实际上是往该对象中添加了一个匹配<code>@Component</code>注解的AnnotationTypeFilter。spring对该类的解释如下：<br>&emsp;&emsp;&emsp;&emsp;<code>A simple filter which matches classes with a given annotation,checking inherited annotations as well.</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="comment">//代码如下：</span></span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;<strong>2-2</strong>) setEnvironment方法:<br>&emsp;&emsp;&emsp;&emsp;一样看名字我们就能知道这是设置环境信息的。就是将之前创建<code>AnnotatedBeanDefinitionReader</code>对象时获取的<code>StandardEnvironment</code>设置给该对象的<code>environment</code>属性。<br>&emsp;&emsp;&emsp;&emsp;<strong>2-3</strong>) setResourceLoader方法:<br>&emsp;&emsp;&emsp;&emsp;该方法分别给该对象的<code>resourcePatternResolver</code>,<code>metadataReaderFactory</code>,<code>componentsIndex</code>属性初始化。<code>resourcePatternResolver</code>对象其实就是容器对象…. <code>metadataReaderFactory</code>是一个从容器<code>resourceCaches</code>属性拷贝过来的<code>ConcurrentHashMap</code>。<code>resourcePatternResolver</code>可能是在加载<code>META-INF/spring.components</code>这个配置文件吧。具体我也不太清楚。<br>&emsp;&emsp;&emsp;&emsp;<strong>至此spring容器的无参构造函数终于时调用完成了(😓)这只是简单的一步而且很多地方即使是知道了它在干什么还是不清楚他为什么这么做如果有更了解的大佬还望指教</strong>  </p><h4 id="2-register方法调用："><a href="#2-register方法调用：" class="headerlink" title="2.register方法调用："></a>2.register方法调用：</h4><p>&emsp;&emsp;该方法就是调用之前创建的<code>AnnotatedBeanDefinitionReader</code>对象的<code>register</code>方法将我们所传入的配置类注册到容器当中。我们可以直接看<code>AnnotatedBeanDefinitionReader</code>对象的<code>doRegisterBean</code>方法：<br>&emsp;&emsp;该方法先是创建了一个<code>AnnotatedGenericBeanDefinition</code>对象。之后通过<code>resolveScopeMetadata</code>方法设置类的定义信息如scope，代理信息，lazy，primary。之后就是将该类注册到容器中。我们来看下这些方法<code>shouldSkip</code>,<code>resolveScopeMetadata</code>,<code>processCommonDefinitionAnnotations</code>,<code>applyScopedProxyMode</code>,<code>registerBeanDefinition</code>  </p><p><img src="http://ww1.sinaimg.cn/large/007BVBG7gy1fzonkylu48j30y00guwfe.jpg" alt="img"><br>&emsp;&emsp;&emsp;&emsp;<strong><em>1)</em></strong> shouldSkip方法：<br>&emsp;&emsp;&emsp;&emsp;该方法先通过<code>isAnnotated</code>判断有没有<code>@Conditional</code>注解如果有则判断该类是否符合注入要求。<br>&emsp;&emsp;&emsp;&emsp;<strong>1-2</strong>) 我们先来看下他是如何判断有没有该注解的：<br>&emsp;&emsp;&emsp;&emsp;首先是<code>searchWithGetSemantics</code>方法来查出该类所有注解。<code>searchWithGetSemanticsInAnnotations</code>来做判断。如果该注解不是java包中的注解。则判断它是否是<code>@Conditional</code>注解或者任何时候都忽略的process。之后递归调用<code>searchWithGetSemantics</code>来看元注解有没有包含<code>@Conditional</code>的。以下为判断源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">    Class&lt;? extends Annotation&gt; currentAnnotationType = annotation.annotationType();</span><br><span class="line"><span class="keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (currentAnnotationType == annotationType ||</span><br><span class="line">currentAnnotationType.getName().equals(annotationName) ||</span><br><span class="line">processor.alwaysProcesses()) &#123;</span><br><span class="line">T result = processor.process(element, annotation, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (processor.aggregates() &amp;&amp; metaDepth == <span class="number">0</span>) &#123;</span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Repeatable annotations in container?</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currentAnnotationType == containerType) &#123;</span><br><span class="line"><span class="keyword">for</span> (Annotation contained : getRawAnnotationsFromContainer(element, annotation)) &#123;</span><br><span class="line">T result = processor.process(element, contained, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No need to post-process since repeatable annotations within a</span></span><br><span class="line"><span class="comment">// container cannot be composed annotations.</span></span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&emsp;&emsp;<strong>1-3</strong>)<br>&emsp;&emsp;&emsp;&emsp;<strong><em>2)</em></strong> resolveScopeMetadata方法：</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这篇博客完全是对Spring的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多(准备好瓜子和板凳😀)。希望喜欢的小伙伴给博主的&lt;a href=&quot;https://github.com/hiyouka/spring-cloud-resources&quot; title=&quot;github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;点个star或者follow一波(&lt;em&gt;^_^&lt;/em&gt;)。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>多线程事务问题的记录</title>
    <link href="https://hiyouka.top/transaction/thread-save/"/>
    <id>https://hiyouka.top/transaction/thread-save/</id>
    <published>2019-01-23T01:13:00.000Z</published>
    <updated>2019-02-13T01:48:09.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
    
    </summary>
    
      <category term="事务" scheme="https://hiyouka.top/categories/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="多线程" scheme="https://hiyouka.top/categories/%E4%BA%8B%E5%8A%A1/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Transaction" scheme="https://hiyouka.top/tags/Transaction/"/>
    
      <category term="Thread" scheme="https://hiyouka.top/tags/Thread/"/>
    
  </entry>
  
</feed>
