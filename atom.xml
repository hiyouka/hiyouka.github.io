<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hiyouka</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiyouka.top/"/>
  <updated>2019-08-27T08:30:05.238Z</updated>
  <id>https://hiyouka.top/</id>
  
  <author>
    <name>hiyouka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot AOP分析</title>
    <link href="https://hiyouka.top/spring/spring-aop/"/>
    <id>https://hiyouka.top/spring/spring-aop/</id>
    <published>2019-08-23T03:19:00.000Z</published>
    <updated>2019-08-27T08:30:05.238Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/08/27/m5ITL6.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;原来只是想看下Spring事务管理的原理,但在寻找事务起作用的源头时,就把Aop的代码几乎看遍了。。。所以就顺便写了一篇关于Aop原理的文章。希望能帮到大家(<em>^_^</em>)<br><a id="more"></a></p><h3 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h3><p>&emsp;&emsp;和看事务管理一样,还是根据SpringBoot配置了哪些关键类来分析原理。可以从Spring.factories找到Spring自动配置类<code>AopAutoConfiguration</code>。该类根据配置文件有没有spring.aop.auto=true(该值默认为true)来注入Spring容器。通过下图可以看出注入该类会添加<code>@EnableAspectJAutoProxy</code>注解,所以我们可以很清楚的看出,springboot默认是开启aop功能的，如果想禁用需要设置属性<code>spring.aop.auto=false</code>。而<code>@EnableAspectJAutoProxy</code>向spring容器中添加了自定义配置Aop起作用的关键类<code>AnnotationAwareAspectJAutoProxyCreator</code><br><img src="https://user-gold-cdn.xitu.io/2019/8/23/16cbc76510428278?w=953&amp;h=525&amp;f=jpeg&amp;s=264606" alt="img"></p><h3 id="Aop原理"><a href="#Aop原理" class="headerlink" title="Aop原理"></a>Aop原理</h3><h4 id="代理类的创建"><a href="#代理类的创建" class="headerlink" title="代理类的创建"></a>代理类的创建</h4><p>&emsp;&emsp;SpringBoot自动配置给容器加入了Aop的核心类,<code>AnnotationAwareAspectJAutoProxyCreator</code>,该类实现了SmartInstantiationAwareBeanPostProcessor接口,所以在bean的创建前后分别会调用该类的<code>postProcessBeforeInstantiation</code>和<code>postProcessAfterInstantiation</code>方法。<br>&emsp;&emsp;<code>postProcessBeforeInstantiation</code>方法会获取TargetSource来在对象创建前调用createProxy来创建代理对象。目前还没搞清楚什么情况会有TargetSource。  &emsp;&emsp;<code>postProcessAfterInstantiation</code>方法调用wrapIfNecessary方法,先获取所有的切点拦截器,创建的时候与代理类所绑定。具体创建代理类的逻辑实在是没看懂,Spring自己封装了cglib代理类实现,不过也是创建了<code>DynamicAdvisedInterceptor</code>为主拦截器的代理类,还有之前查找的所有切面拦截器。下面源码就是Spirng通过我们配置的切面表示创建Advisor的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="comment">//第一次去获取切面配置类</span></span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 获取所有类名 遍历</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line"><span class="comment">// 如果该类有@Aspect注解，并且不是AspectJ类</span></span><br><span class="line"><span class="comment">//We need to detect this as "code-style" AspectJ aspects should not be interpreted by Spring AOP.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">aspectNames.add(beanName);</span><br><span class="line">AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line"><span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="comment">//创建对方法进行增强处理的Advisor(InstantiationModelAwarePointcutAdvisorImpl)</span></span><br><span class="line"><span class="comment">//该增强器默认有AspectJExpressionPointcut作为你匹配,之后进行matches是会使用</span></span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">&#125;</span><br><span class="line">advisors.addAll(classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Per target or per this.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line"><span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/0071eGtVly1g68h3qb02vj30tv0apt99.jpg" alt="img"><br> &emsp;&emsp;<code>DynamicAdvisedInterceptor</code>类是Aop每个代理类都有的拦截器,当调用代理类的方法时,首先会调用该类的<code>intercept</code>方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 对aop暴露进行处理,如果暴露则将代理类置入当前线程中，之后嵌套调用可以取到</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取原始对象(代理前对象)</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 获取拦截器链,就是在创建代理类前获取的拦截处理器，对方法进行匹配，和之前讲的事务Advisor一样</span></span><br><span class="line"><span class="comment">// 通过MethodMatcher来匹配,这边是AspectJExpressionPointcut的mathces对表达式进行解析</span></span><br><span class="line"><span class="comment">// 自定义的切面是通过之前的Advisor来生成的拦截器</span></span><br><span class="line"><span class="comment">// MethodBeforeAdviceAdapter AfterReturningAdviceAdapter ThrowsAdviceAdapter</span></span><br><span class="line"><span class="comment">//通过是否匹配上面三种adapter分别生成 </span></span><br><span class="line"><span class="comment">//MethodBeforeAdviceInterceptor AfterReturningAdviceInterceptor ThrowsAdviceInterceptor</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="comment">// 没有增强处理器直接执行原始对象的方法</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//调用CglibMethodInvocation.process(),</span></span><br><span class="line"><span class="comment">//该方法会递归执行所有拦截器链中的方法，知道调用完成原始方法</span></span><br><span class="line">retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对返回结果进行处理</span></span><br><span class="line">retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他Spring切面"><a href="#其他Spring切面" class="headerlink" title="其他Spring切面"></a>其他Spring切面</h3><p> &emsp;&emsp;<code>@EnableAsync</code>可以开启Spring管理的线程池,利用注解方式简单实现方法多线程调用。但是有一点需要注意(我觉得是Spring的bug),该注解实现还是利用的Aop,但是使用另一个Bean后置处理器:<code>AsyncAnnotationBeanPostProcessor</code>,从下面代码可以看出,在bean创建完成后会对未代理过的类创建代理对象,如果已经是代理类则添加一个切面处理器进去。由于在新创建代理类的时候使用的是独立的后置处理器，所以在切面设置的一些属性对<code>@Async</code>无效（例如expose暴露）。所以如果想让只有<code>@Async</code>注解的代理类，想要使暴露生效只能额外对该后置处理器添加属性。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisor == <span class="keyword">null</span> || bean <span class="keyword">instanceof</span> AopInfrastructureBean) &#123;</span><br><span class="line"><span class="comment">// Ignore AOP infrastructure such as scoped proxies.</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 如果该bean已经被处理过（代理类）</span></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">Advised advised = (Advised) bean;</span><br><span class="line"><span class="comment">// 如果需要被处理（有@Async注解）</span></span><br><span class="line"><span class="keyword">if</span> (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123;</span><br><span class="line"><span class="comment">// Add our local Advisor to the existing proxy's Advisor chain...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beforeExistingAdvisors) &#123;</span><br><span class="line">advised.addAdvisor(<span class="number">0</span>, <span class="keyword">this</span>.advisor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">advised.addAdvisor(<span class="keyword">this</span>.advisor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果需要被处理（有@Async注解）</span></span><br><span class="line"><span class="keyword">if</span> (isEligible(bean, beanName)) &#123;</span><br><span class="line">ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);</span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">evaluateProxyInterfaces(bean.getClass(), proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">proxyFactory.addAdvisor(<span class="keyword">this</span>.advisor);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No proxy needed.</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p> &emsp;&emsp;Spring通过为元类创建代理类添加<code>DynamicAdvisedInterceptor</code>的拦截器来实现拦截器链,通过拦截器链我们自己创建的切面添加到拦截器链当中（可以自定义顺序），这样非常灵活方便的为我们提供了对类方法扩展的功能。<a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">另外推荐一篇对AOP扩展的文章，写的很好。</a>觉得本文对你有帮助的小伙伴不妨点个赞，你们的关注是我继续下去的动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/08/27/m5ITL6.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;原来只是想看下Spring事务管理的原理,但在寻找事务起作用的源头时,就把Aop的代码几乎看遍了。。。所以就顺便写了一篇关于Aop原理的文章。希望能帮到大家(&lt;em&gt;^_^&lt;/em&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="aop" scheme="https://hiyouka.top/tags/aop/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot事务管理</title>
    <link href="https://hiyouka.top/spring/spring-transaction/"/>
    <id>https://hiyouka.top/spring/spring-transaction/</id>
    <published>2019-08-08T07:17:00.000Z</published>
    <updated>2019-08-27T08:30:05.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0071eGtVly1g6cw82w5bkj31hc0u0k3o.jpg" alt="img"></p><h3 id="SpringBoot事务管理"><a href="#SpringBoot事务管理" class="headerlink" title="SpringBoot事务管理"></a>SpringBoot事务管理</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&emsp;&emsp;好久没有写博客了,最近终于能沉下心来阅读底层源码了(主要是上班时间比较闲(●’◡’●))。本文部分内容涉及spring容器没有细讲,有兴趣的同学可以去看我容器启动分析的文章(写的第一篇文章比较烂，有时间应该会重新整理下)。<br><a id="more"></a></p><h4 id="springboot自动配置基本原理"><a href="#springboot自动配置基本原理" class="headerlink" title="springboot自动配置基本原理"></a>springboot自动配置基本原理</h4><p>&emsp;&emsp;SpringBoot首先在启动的时候会读取项目下的”META-INF/spring.factories”路径的自动配置类,过滤器,监听器,ApplicationContextInitializer等。mybatis的自动装配就引入了MybatisAutoConfiguration类。<br>&emsp;&emsp;分析mybatis的自动装配前需要来分析下@EnableAutoConfiguration注解,SpringBoot的启动注解@SpringBootApplication就自带该注解,该注解引入了两个类分别是AutoConfigurationImportSelector,AutoConfigurationPackages.Registrar。</p><ol><li>AutoConfigurationImportSelector: 该类实现了DeferredImportSelector接口(继承ImportSelector接口),所以在spring进行容器刷新的时候会调用该类的selectImports方法将一些组件注册进容器当中。<br>这个类的selectImports方法：<ol><li>从项目中读取”META-INF/spring-autoconfigure-metadata.properties”文件的内容(自动装配引入的类)。</li><li>从缓存中获取EnableAutoConfiguration类的类名(SpringBoot启动时读取的自动配置类);</li><li>移除配置的忽略类(@SpringBootApplication/@EnableAutoConfiguration的exclude属性配置)</li><li>使用过滤器筛选自动配置类。SpringBoot默认注册了OnClassCondition过滤器,在spring-autoconfigure-metadata.properties的配置文件中需要配置ConditionalOnClass对应的value就是OnClassCondition类去判断的类)该过滤器筛选掉ClassLoader中缺失所需类的自动装配类。</li></ol></li><li>AutoConfigurationPackages.Registrar:将AutoConfigurationPackages类注册入容器,目前还不清楚该类的作用。官方描述：Class for storing auto-configuration packages for reference later (e.g. by JPA entity scanner).<br>SpringBoot读取自动装配类流程图如下：<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1csxz0lraj30xf0dy76r.jpg" alt="img"></li></ol><h3 id="事务相关的自动配置-JDBC"><a href="#事务相关的自动配置-JDBC" class="headerlink" title="事务相关的自动配置(JDBC)"></a>事务相关的自动配置(JDBC)</h3><p>&emsp;&emsp;事务相关的自动配置需要关注的有三个类，第一个是<code>@EnableTransactionManagement</code>springboot用于开启事务的注解，其他两个类是通过spring.factories读取的配置类分别是<code>TransactionAutoConfiguration</code>、<code>DataSourceTransactionManagerAutoConfiguration</code>这些类用于向spring容器中注入一些事务相关的关键类。(这里分析的是JDBC方向的，JTA原理类似)</p><h4 id="DataSourceTransactionManagerAutoConfiguration"><a href="#DataSourceTransactionManagerAutoConfiguration" class="headerlink" title="DataSourceTransactionManagerAutoConfiguration"></a>DataSourceTransactionManagerAutoConfiguration</h4><p><img src="https://ws1.sinaimg.cn/large/0071eGtVly1g5s2kp91isj30wh0kvab7.jpg" alt="img"></p><p>&emsp;&emsp;DataSourceTransactionManagerAutoConfiguration该类主要向容器注入PlatformTransactionManager类,这边注入的是DataSourceTransactionManager(注意的是这个类是自动注入最低优先级的，应该是考虑到让DataSource等先注册)</p><p><img src="https://ws1.sinaimg.cn/large/0071eGtVly1g5s2uc5ze2j312z0n9gn8.jpg" alt="img"></p><h4 id="TransactionAutoConfiguration"><a href="#TransactionAutoConfiguration" class="headerlink" title="TransactionAutoConfiguration"></a>TransactionAutoConfiguration</h4><p>&emsp;&emsp;TransactionAutoConfiguration该类主要向容器注入TransactionTemplate和支持spring的事务管理只要容器中有PlatformTransactionManager类就会自动开启事务。所以很多教程springboot开启事务管理需要添加<code>@EnableTransactionManagement</code>注解,其实完全是多余的!只要你在容器中注入有spring的事务管理器就ok了。(springboot的jdbc-starter和jta-starter都帮我们注入了事务管理器)</p><h4 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="EnableTransactionManagement"></a>EnableTransactionManagement</h4><p>&emsp;&emsp;该类就使用@Import向容器注入了TransactionManagementConfigurationSelector类,该类实现了ImportSelector<br>接口,向容器注入了AutoProxyRegistrar和ProxyTransactionManagementConfiguration类(默认的Proxy)。重点要看的是ProxyTransactionManagementConfiguration类。</p><h5 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h5><p>&emsp;&emsp;ProxyTransactionManagementConfiguration实现了AbstractTransactionManagementConfiguration类。该类有个<code>setConfigurers</code>方法,该方法会将TransactionManagementConfigurer的实现类返回的PlatformTransactionManager返回赋值给TransactionInterceptor用于多事务管理器的默认管理。<br>&emsp;&emsp;ProxyTransactionManagementConfiguration像spring容器添加了三个了：</p><ol><li>TransactionalEventListenerFactory,事务的监听器,这个不管。</li><li>AnnotationTransactionAttributeSource,该类用于解析类或方法上的事务注解。</li><li>TransactionInterceptor,该类是事务起作用的核心类,当执行事务切面的时候就是执行该类的invoke方法</li><li>BeanFactoryTransactionAttributeSourceAdvisor,该类在aop生成代理类的时候会作为管理类被加入到aop的拦截器链用于触发回调,执行事务操作。该类的TransactionAttributeSourcePointcut属性在创建代理对象的时候调用match方法扫描该类及其所有方法,来确定该类是否需要被该拦截器处理。（aop的执行可以看我另外一篇博客）。</li></ol><h4 id="事务原理分析"><a href="#事务原理分析" class="headerlink" title="事务原理分析"></a>事务原理分析</h4><p>&emsp;&emsp;主要看TransactionInterceptor的invoke方法，前面也说到当执行到代理对象的方法时会获取该方法的所有拦截器来进行处理。事务添加的就是TransactionInterceptor拦截器。<br>&emsp;&emsp;invokeWithinTransaction方法：<br>下图可以很明显的看出四步</p><ol><li>开启事务: createTransactionIfNecessary</li><li>执行方法：processedWithInvocation</li><li>如果出错回滚：completeTransactionAfterThrowing</li><li>提交事务：commitTransactionAfterReturning</li></ol><h5 id="createTransactionIfNecessary"><a href="#createTransactionIfNecessary" class="headerlink" title="createTransactionIfNecessary"></a>createTransactionIfNecessary</h5><p>&emsp;&emsp; 关键PlatformTransactionManager.getTransaction();本质操作就是获取数据库连接,jdbc环境使用的就是DataSourceTransactionManager。简单讲一下就是根据事务的传播机制获取连接，然后根据readOnly、隔离级别等给连接设置属性，还有对事务状态等控制。</p><h5 id="processedWithInvocation"><a href="#processedWithInvocation" class="headerlink" title="processedWithInvocation"></a>processedWithInvocation</h5><p>&emsp;&emsp; 执行该类的方法，通过java8的FunctionalInterface将方法传入调用。   </p><h5 id="completeTransactionAfterThrowing"><a href="#completeTransactionAfterThrowing" class="headerlink" title="completeTransactionAfterThrowing"></a>completeTransactionAfterThrowing</h5><p>&emsp;&emsp; DataSourceTransactionManager的doRollback，最终调用的就是connection.rollback()(如果异常是Error||RuntimeException)。其他还对事务的状态进行校验，获取savepoint，判断是否为嵌套事务等。  </p><h5 id="commitTransactionAfterReturning"><a href="#commitTransactionAfterReturning" class="headerlink" title="commitTransactionAfterReturning"></a>commitTransactionAfterReturning</h5><p>&emsp;&emsp; DataSourceTransactionManager的doCommit,最终调用的就是connection.commit(),如果是嵌套继承的事务则不会提交。</p><p><img src="https://ws1.sinaimg.cn/large/0071eGtVly1g67di69b3vj30xn0ivjsd.jpg" alt="img"></p><h4 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h4><h5 id="事务并发引发问题"><a href="#事务并发引发问题" class="headerlink" title="事务并发引发问题"></a>事务并发引发问题</h5><blockquote><p><em>脏读</em></p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    事务<span class="number">1</span> update data <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line">    事务<span class="number">2</span> read data <span class="number">2</span></span><br><span class="line">    事务<span class="number">1</span> rollback data <span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">    事务<span class="number">1</span> commit</span><br><span class="line">    事务<span class="number">1</span> <span class="keyword">return</span> data <span class="number">2</span></span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">&gt; *丢失修改*  </span><br><span class="line">    </span><br><span class="line">```php    </span><br><span class="line">    事务<span class="number">1</span> read data <span class="number">1</span></span><br><span class="line">    事务<span class="number">2</span> read data <span class="number">1</span></span><br><span class="line">    事务<span class="number">1</span> update data <span class="number">1</span> + <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line">    事务<span class="number">2</span> update data <span class="number">1</span> + <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line">    事务<span class="number">1</span> commit</span><br><span class="line">    事务<span class="number">2</span> commit</span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">&gt; *不可重复读* </span><br><span class="line">    </span><br><span class="line">```php    </span><br><span class="line">    事务<span class="number">1</span> read data <span class="number">1</span></span><br><span class="line">    事务<span class="number">2</span> updata data <span class="number">1</span> &gt; <span class="number">2</span></span><br><span class="line">    事务<span class="number">2</span> commit</span><br><span class="line">    事务<span class="number">1</span> read data <span class="number">2</span></span><br><span class="line">```    </span><br><span class="line">    </span><br><span class="line">&gt; *幻读*  </span><br><span class="line"> </span><br><span class="line"> ```php</span><br><span class="line">    事务<span class="number">1</span> read data num <span class="number">2</span></span><br><span class="line">    事务<span class="number">2</span> insert delete num <span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">    事务<span class="number">2</span> commit</span><br><span class="line">    事务<span class="number">1</span> commit</span><br><span class="line">    事务<span class="number">1</span> <span class="keyword">return</span> data num <span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><blockquote><p><em>read uncommitted</em>  </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个事务可以读取另一个事务未提交事务的数据。</span><br><span class="line">读未提交会引起脏读，不可重复读、幻读、丢失修改</span><br></pre></td></tr></table></figure><blockquote><p><em>read committed</em> （orcale默认）</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个事务可以读取到另一个事务提交的数据。</span><br><span class="line">读已提交解决了脏读，但还是会引起不可重复读、幻读、丢失修改。</span><br></pre></td></tr></table></figure><blockquote><p><em>repeatable read</em> （mysql默认）</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可重复读。一个事务对同一份数据读取到的相同，不在乎其他事务对数据的修改。</span><br><span class="line">解决不可重复读。（实现机制是在事务A读取之后将这些数据添加行级锁，其他事务无法修改：待验证）</span><br><span class="line">会产生幻读，丢失修改。</span><br><span class="line">丢失修改可通过数据库互斥锁（悲观锁）来解决，</span><br><span class="line">或者在字段中加入版本号（乐观锁），也可以代码中自行加锁。如果这个级别自动在查询后添加行级锁，那么其他修改无法执行，就能解决丢失修改问题。</span><br></pre></td></tr></table></figure><blockquote><p><em>serializable</em>  </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">严格的数据隔离，要求事务序列化执行，事务只能一个接一个执行。</span><br><span class="line">严重影响并发能力。</span><br><span class="line">解决所有并发事务引起问题。</span><br></pre></td></tr></table></figure><h5 id="spring事务管理"><a href="#spring事务管理" class="headerlink" title="spring事务管理"></a>spring事务管理</h5><h6 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h6><p><code>TransactionDefinition</code>接口中定义了五个表示隔离级别的常量：</p><ol><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生<br><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>     最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ol><h6 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h6><p><code>TransactionDefinition</code>接口中定义了五个表示隔离级别的常量：</p><blockquote><p>支持当前事务的情况:</p><ol><li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong><br>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS:</strong><br>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong><br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<br>不支持当前事务的情况：</li><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong><br>创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</strong><br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong><br>以非事务方式运行，如果当前存在事务，则抛出异常。<br>其他情况：</li><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong><br>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ol></blockquote><p>&emsp;&emsp;这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 PROPAGATION_NESTED 是 Spring 所特有的。以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</p><h6 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h6><p>&emsp;&emsp;所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p><h6 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h6><p>&emsp;&emsp;事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p><h6 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h6><p>&emsp;&emsp;这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;Spring通过良好的api将事务管理和数据源封装了起来,让我们可以很轻松的使用不同环境中的事务,但我觉得Spring事务管理这块扩展性还是略微有些差的,例如我原先想将事务支持多线程同一事务,原以为只要将每个线程的保存的连接统一即可,但随后发现必须要重写拦截器才能实现,Spring拦截器不对外修改事务状态以及一些处理的覆盖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0071eGtVly1g6cw82w5bkj31hc0u0k3o.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;SpringBoot事务管理&quot;&gt;&lt;a href=&quot;#SpringBoot事务管理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot事务管理&quot;&gt;&lt;/a&gt;SpringBoot事务管理&lt;/h3&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;好久没有写博客了,最近终于能沉下心来阅读底层源码了(主要是上班时间比较闲(●’◡’●))。本文部分内容涉及spring容器没有细讲,有兴趣的同学可以去看我容器启动分析的文章(写的第一篇文章比较烂，有时间应该会重新整理下)。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
      <category term="transaction" scheme="https://hiyouka.top/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>一致性算法</title>
    <link href="https://hiyouka.top/algorithmic/algorithm-transactional/"/>
    <id>https://hiyouka.top/algorithmic/algorithm-transactional/</id>
    <published>2019-04-30T09:20:32.000Z</published>
    <updated>2019-08-27T08:30:05.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h3><p>&emsp;&emsp;二阶段提交思路：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。第一阶段-请求阶段(表决阶段)，第二阶段-提交阶段(执行阶段)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二阶段提交&quot;&gt;&lt;a href=&quot;#二阶段提交&quot; class=&quot;headerlink&quot; title=&quot;二阶段提交&quot;&gt;&lt;/a&gt;二阶段提交&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;二阶段提交思路：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是
      
    
    </summary>
    
      <category term="algorithmic" scheme="https://hiyouka.top/categories/algorithmic/"/>
    
    
      <category term="algorithmic,consistency" scheme="https://hiyouka.top/tags/algorithmic-consistency/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析(结合SpringBoot自动配置)</title>
    <link href="https://hiyouka.top/mybatis/mybatis-spring/"/>
    <id>https://hiyouka.top/mybatis/mybatis-spring/</id>
    <published>2019-03-20T07:54:20.000Z</published>
    <updated>2019-08-27T08:30:05.222Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g19bzb8qg4j309q02gq2s.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;之前阅读了spring的ioc容器初始化源码感觉阅读源码还是一件很有意义的事情,除了能了解它们底层的实现方式,还能学习它们使用的巧妙设计模式,于是想着再阅读一下常用框架mybatis的原理。这次为了更清晰的记录框架结构采用了画图的方式,也方便了以后复习回忆。(<a href="https://github.com/hiyouka/spring-cloud-resources" target="_blank" rel="noopener">项目demo地址</a>)<br><a id="more"></a></p><h3 id="注册mapper接口类"><a href="#注册mapper接口类" class="headerlink" title="注册mapper接口类"></a>注册mapper接口类</h3><p>&emsp;&emsp;首先从MapperScan注解开始它引入了一个类MapperScannerRegistrar。该类实现了ImportBeanDefinitionRegistrar接口,所以在spring容器启动的时候会在ConfigurationClassBeanDefinitionReader调用loadBeanDefinitions的时候调用该类的registerBeanDefinitions方法将@MapperScan配置的路径中的class类添加到spring容器当中(spring源码解析中有关于容器启动的过程解析)。</p><ol><li>该类的registerBeanDefinitions方法首先是创建了一个ClassPathMapperScanner类(继承了spring的扫包类ClassPathBeanDefinitionScanner)。</li><li>给ClassPathMapperScanner设置了一些注册过滤器(根据@MapperScan注解的markerInterface属性添加过滤器,还会添加一个始终为true的过滤器)。</li><li>调用父类的doScan方法将bean定义信息注册到容器当中。</li><li>通过processBeanDefinitions方法,主要就是将该类定义信息封装成MapperFactoryBean(实现spring的FactoryBean),还会给bean定义信息添加ConstructorArgumentValues让spring之后创建该MapperFactoryBean的时候调用以该接口class为参数的构造函数来创建对象。容器对象实例化getBean的时候将会调用MapperFactoryBean的getObject。<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1bcwin1ugj30s708zjrj.jpg" alt="img"><br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g19cyry8qtj30gm03d745.jpg" alt="img"></li></ol><h3 id="mapper接口类的创建"><a href="#mapper接口类的创建" class="headerlink" title="mapper接口类的创建"></a>mapper接口类的创建</h3><p>&emsp;&emsp;在第一个Mapper接口类创建的时候会创建sqlSessionFactory,sqlSessionTemplate(如果没有手动注册的话)。这些类是由mybatis的自动配置类来注册创建的,之后会详细分析。创建Mapper类的实例就是调用MapperFactoryBean的getObject,最终调用的是MapperRegistry的getMapper,从下图可以看出来实现原理就是使用java的动态代理来创建一个代理对象,代理类为MapperProxy类。<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1ae59ihc8j30pi05jq32.jpg" alt="img"><br>&emsp;&emsp;在MapperFactoryBean创建完成之后会执行初始化方法(DaoSupport实现了InitializingBean接口),初始化方法中调用了checkDaoConfig和initDao方法。<br>MapperFactoryBean重写了checkDaoConfig方法。MapperRegistry类管理着mapper类和MapperProxyFactory映射的map集合。<br>checkDaoConfig方法：</p><ol><li>MapperAnnotationBuilder的loadXmlResource获取xml文件资源(这里要提一下, mybatis直接通过mapper文件路径寻找xml,如果mapper接口与xml路径不一致会导致无法读取到xml文件而且最坑的是它把异常给捕获了,即使找不到启动也不会报错,而会在你调用mapper方法的时候再报错。。。)获取到xml资源创建创建loadXmlResource对象<ol><li>createDocument 读取xml的document对象并封装在XPathParser对象中。</li><li>configurationElement,利用XpathParser解析mapper,resultMap,sql等dom节点信息。</li><li>buildStatementFromContext 读取sql语句(insert/update/delete/select节点),封装成MappedStatement对象并添加到Configuration中。</li></ol></li><li>MapperAnnotationBuilder的parseStatement方法将基于注解的sql信息封装到成MappedStatement添加到Configuration。<br>mybatis初始化动态sql图解：<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1bplmlsgkj30uy0kv770.jpg" alt="img"></li></ol><h3 id="mybatis的自动配置-SpringBoot"><a href="#mybatis的自动配置-SpringBoot" class="headerlink" title="mybatis的自动配置(SpringBoot)"></a>mybatis的自动配置(SpringBoot)</h3><p>&emsp;&emsp;SpringBoot首先在启动的时候会读取项目下的”META-INF/spring.factories”路径的自动配置类,过滤器,监听器,ApplicationContextInitializer等。mybatis的自动装配就引入了MybatisAutoConfiguration类。<br>&emsp;&emsp;分析mybatis的自动装配前需要来分析下@EnableAutoConfiguration注解,SpringBoot的启动注解@SpringBootApplication就自带该注解,该注解引入了两个类分别是AutoConfigurationImportSelector,AutoConfigurationPackages.Registrar。</p><ol><li>AutoConfigurationImportSelector: 该类实现了DeferredImportSelector接口(继承ImportSelector接口),所以在spring进行容器刷新的时候会调用该类的selectImports方法将一些组件注册进容器当中。<br>这个类的selectImports方法：<ol><li>从项目中读取”META-INF/spring-autoconfigure-metadata.properties”文件的内容(自动装配引入的类)。</li><li>从缓存中获取EnableAutoConfiguration类的类名(SpringBoot启动时读取的自动配置类);</li><li>移除配置的忽略类(@SpringBootApplication/@EnableAutoConfiguration的exclude属性配置)</li><li>使用过滤器筛选自动配置类。SpringBoot默认注册了OnClassCondition过滤器,在spring-autoconfigure-metadata.properties的配置文件中需要配置ConditionalOnClass对应的value就是OnClassCondition类去判断的类)该过滤器筛选掉ClassLoader中缺失所需类的自动装配类。</li></ol></li><li>AutoConfigurationPackages.Registrar:将AutoConfigurationPackages类注册入容器,目前还不清楚该类的作用。官方描述：Class for storing auto-configuration packages for reference later (e.g. by JPA entity scanner).<br>SpringBoot读取自动装配类流程图如下：<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1csxz0lraj30xf0dy76r.jpg" alt="img"></li></ol><p>&emsp;&emsp;之后在容器刷新创建类的时候就会自动配置sqlSessionFactory,sqlSessionTemplate类。mybatis的自动装配类中还有一个类MapperScannerRegistrarNotFoundConfiguration,当检测到容器中没有MapperFactory时就会扫描项目中Mapper的类将其作为MapperFactory注册进容器。也就是表示可以不添加@MapperScan注解，只在接口类上加上@Mapper注解就可以注入容器当中了。</p><h3 id="mapper接口方法的执行："><a href="#mapper接口方法的执行：" class="headerlink" title="mapper接口方法的执行："></a>mapper接口方法的执行：</h3><p>&emsp;&emsp;第二部分中提到创建在容器当中的Mapper接口类是一个MapperProxy的代理类。在我们调用Mapper接口的方法时就会执行MapperProxy的invoke方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g19bzb8qg4j309q02gq2s.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;之前阅读了spring的ioc容器初始化源码感觉阅读源码还是一件很有意义的事情,除了能了解它们底层的实现方式,还能学习它们使用的巧妙设计模式,于是想着再阅读一下常用框架mybatis的原理。这次为了更清晰的记录框架结构采用了画图的方式,也方便了以后复习回忆。(&lt;a href=&quot;https://github.com/hiyouka/spring-cloud-resources&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目demo地址&lt;/a&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="mybatis" scheme="https://hiyouka.top/categories/mybatis/"/>
    
    
      <category term="mybatis,SpringBoot" scheme="https://hiyouka.top/tags/mybatis-SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>实现一个ioc容器</title>
    <link href="https://hiyouka.top/seed/ioc/"/>
    <id>https://hiyouka.top/seed/ioc/</id>
    <published>2019-03-09T11:19:00.000Z</published>
    <updated>2019-08-27T08:30:05.277Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g0yw2rag7nj30ha09qgmf.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;之前花了一些时间阅读了一部分spring源码,于是想自己实现一个类似spring容器功能的框架。利用工作之余花了半个月时间总算是写出了一个简单的容器seed。功能模块实现思想和spring类似，希望能够更好的帮助小伙伴了解spring的原理(<a href="https://github.com/hiyouka/seed-framework" target="_blank" rel="noopener">github地址</a>)。<br><a id="more"></a></p><h3 id="容器的刷新"><a href="#容器的刷新" class="headerlink" title="容器的刷新"></a>容器的刷新</h3><p>&emsp;&emsp; seed容器是通过invokeBeanFactoryPostProcessors方法来执行提前注册在容器当中的处理器。该处理的功能就是解析加载进来的配置类。解析配置类上的<code>@ComponentScan</code>,<code>@Import</code>和<code>@Bean</code>注解。将所有<code>@Component</code>标识的组件加载到容器当中并形成bean的定义信息。 该方法通过扫描配置的路径来读取所有的class文件将其封装成Resource对象。之后解析class文件的信息读取到注解信息进行再解析。通过Resource信息来生成BeanDefinition，我这里解析class文件时使用的cglib包中带的asm组件使用里面的ClassReader类来解析class文件再进一步封装成bean的定义信息。<br>&emsp;&emsp;之后调用registerBeanPostProcessor方法将所有的BeanPostProcessor实例化添加到容器当中为之后的bean创建准备工作。<br>&emsp;&emsp;最后就是将所有的单例，非懒加载的bean创建到容器当中。在创建bean时会有一些前置后置处理流程。通过实现BeanPostProcessor接口可以来自定义bean创建时的前置后置处理方法。懒加载对象和多例对象会在调用getBean的时候才去进行创建对象。在getBean的时候将单例对象缓存起来，之后进行bean的获取工作时都是从缓存中获取。在以类型进行getBean的时候会先更具类型查出所有的bean名称，并生成一个类型对应名称的缓存，加快之后获取的效率。根据类型获取单个bean时，或检验bean上有没有@Primary注解。选择由@Primary注解的对象返回。如果都没有则会抛异常。这一点和Spring的实现类似。创建bean就是使用简单的反射调用构造函数来生成对象。在处理@Bean注解的时候和spring有点差异，spring不会将@Bean导入的对象当作配置类继续处理，而我这边的实现会将其作为配置类继续处理。即：在@Bean导入的类上也可以引入其他类。</p><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p>&emsp;&emsp; seed的生命周期和spring容器几乎一致。</p><ol><li>首先是创建初步的bean对象。</li><li>之后再进行bean的依赖注入工作(该功能待完成)。</li><li>调用beanPostProcessor的前置处理方法。</li><li>如果该bean实现Initialization接口那么会先执行afterPropertiesSet方法。之后执行init方法(通过@InitMethod注解来标记init方法)</li><li>调用beanPostProcessor的后置处理方法。</li></ol><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ol><li>通过实现seed的BeanFactoryPostProcessor接口可以再容器扫包之后往容器中添加一些bean定义信息。</li><li>实现EnvironmentAware接口可以往类中添加Environment环境变量类。从该类中可以获取环境变量信息，jvm参数信息，以及使用@PropertySources导入的配置文件数据。</li><li>实现BeanFactoryAware接口可以获取容器的beanFactory。</li><li>实现ApplicationContextAware接口可以获取到ApplicationContext容器。</li><li>容器中默认注册了环境变量信息，以及配置的读取配置文件的数据信息。通过getBean可获取容器中的组件来获取上述信息。</li></ol><p>这些功能都是基于一个后置处理器来实现的。再bean的创建当中如果该bean实现以上接口则会将以上对相应的信息通过接口方法注入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp; 这个项目自己结合spring源码写出来的缩减版ioc容器。其实每一步的程序实现都是比较简单的。难点就在于通用性接口设计，功能抽象等（其实这些我都是模仿的spring😓）。之后这个项目还会加上依赖注入，aop以及web服务的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g0yw2rag7nj30ha09qgmf.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;之前花了一些时间阅读了一部分spring源码,于是想自己实现一个类似spring容器功能的框架。利用工作之余花了半个月时间总算是写出了一个简单的容器seed。功能模块实现思想和spring类似，希望能够更好的帮助小伙伴了解spring的原理(&lt;a href=&quot;https://github.com/hiyouka/seed-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github地址&lt;/a&gt;)。&lt;br&gt;
    
    </summary>
    
      <category term="seed" scheme="https://hiyouka.top/categories/seed/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="seed" scheme="https://hiyouka.top/tags/seed/"/>
    
  </entry>
  
  <entry>
    <title>Spring对象创建初始化分析</title>
    <link href="https://hiyouka.top/spring/getBean/"/>
    <id>https://hiyouka.top/spring/getBean/</id>
    <published>2019-02-20T07:17:00.000Z</published>
    <updated>2019-08-27T08:30:05.271Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g0cutps3irj31kw0oy4qp.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;在分析spring容器的创建过程中分析了bean的创建过程。由于创建过程步骤还是比较多的于是就新开一篇博客来详细分析下beanFactory的getBean方法做了哪些操作。分析的是通过beanType获取bean，因为根据type获取其实最终调用的也是根据beanName获取bean。<br><a id="more"></a></p><h3 id="resolveNamedBean："><a href="#resolveNamedBean：" class="headerlink" title="resolveNamedBean："></a>resolveNamedBean：</h3><p>这个方法的目的是根据类型获取beanNames：</p><ol><li><p>getBeanNamesForType：</p><ol><li>先从缓存中获取该类型的所有beanName。</li><li><p>如果1没有获取到执行doGetBeanNamesForType：</p><ol><li>遍历所有的bean查找符合该类型的的单例bean和单例bean工厂对象。</li><li>从<code>manualSingletonNames</code>(容器创建时无参构造函数初始化的bean)中获取符合的单例bean和单例bean工厂对象。（这边要注意在返回工厂bean名称时需要加上<code>&amp;</code>)</li><li>返回所有该对象或对象工厂的集合。</li></ol></li><li><p>将获取的beanNames放入缓存中。</p></li></ol></li><li>筛选出这些beanName中不在beanDefinitionMap集合中或者允许自动注入的bean。</li><li>如果1中获取的beanNames大于一个，获取需要的beanName：(在这一步的时候已经调用getBean(beanName获取了对象))<ol><li>determinePrimaryCandidate来解析<code>@Primary</code>信息。如果只有一个beanName的定义信息被注册到该beanFactory或者该beanFactory的<code>parentBeanFactory</code>中 并且该beanName的定义信息为Primary。返回该beanName。</li><li>如果1没获取到determineHighestPriorityCandidate获取。遍历获取这些bean的<code>@Priority</code>的优先级代号(数字越小优先级越高)，返回优先级最高的bean名称。</li></ol></li><li>获取到beanName后通过beanName返回包含该对象的NamedBeanHolder。</li></ol><p>resolveNamedBean的操作源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="comment">//if not allow cache all bean or allowEagerInit ? 这个条件看不懂</span></span><br><span class="line">    <span class="comment">//isConfigurationFrozen if is true mean this context init finish</span></span><br><span class="line">    <span class="comment">//get bean name from beanDefinitionNames and manualSingletonNames</span></span><br><span class="line"><span class="keyword">if</span> (!isConfigurationFrozen() || type == <span class="keyword">null</span> || !allowEagerInit) &#123;</span><br><span class="line"><span class="keyword">return</span> doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if allow cache all bean get bean name from cache first(isConigurationFrozen is true)</span></span><br><span class="line">Map&lt;Class&lt;?&gt;, String[]&gt; cache = // includeNonSingletons : 是否包含非单例对象</span><br><span class="line">(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);</span><br><span class="line">String[] resolvedBeanNames = cache.get(type);</span><br><span class="line"><span class="keyword">if</span> (resolvedBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if can not get this bean type from cache ,get bean name from beanDefinitionNames and manualSingletonNames</span></span><br><span class="line">resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// here is some safe check:  such as whether or not this bean classLoader to the beanFatory classLoader(具体我也不太清楚)</span></span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">cache.put(type, resolvedBeanNames); <span class="comment">// put this beanname to cache</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">`doGetBeanNamesForType`操作源码： </span><br><span class="line">        </span><br><span class="line">```php</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">List</span>&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Check all bean definitions.</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : this.beanDefinitionNames) &#123;</span><br><span class="line">    <span class="comment">// Only consider bean as eligible if the bean name</span></span><br><span class="line">    <span class="comment">// is not defined as alias for some other bean.</span></span><br><span class="line">    <span class="keyword">if</span> (!isAlias(beanName)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// Only check bean definition if it is complete.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">    (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">    !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">    boolean isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    boolean matchFound =</span><br><span class="line">    (allowEagerInit || !isFactoryBean ||</span><br><span class="line">    (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">    (includeNonSingletons ||</span><br><span class="line">    (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">    isTypeMatch(beanName, type);</span><br><span class="line">    <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">    matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">    result.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CannotLoadBeanClassException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check manually registered singletons too.</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : this.manualSingletonNames) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">    <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">    result.add(beanName);</span><br><span class="line">    <span class="comment">// Match found for this bean: do not match FactoryBean itself anymore.</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, try to match FactoryBean itself next.</span></span><br><span class="line">    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Match raw bean instance (might be raw FactoryBean).</span></span><br><span class="line">    <span class="keyword">if</span> (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">    result.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br></pre></td></tr></table></figure></p><h3 id="getBean-beanName"><a href="#getBean-beanName" class="headerlink" title="getBean(beanName):"></a>getBean(beanName):</h3><p>&emsp;&emsp;&emsp;&emsp;该方法通过beanName获取bean，实际操作在<code>doGetBean</code>方法中：  </p><ol><li>该方法先是判断该bean是否被注册(工厂bean需去除<code>&amp;</code>),之后调用<code>getSingleton</code>试图获取bean实例:<ol><li>从单例对象缓存中获取bean。</li><li>若1未获取到并且该对象正在创建则锁定单例缓存从早期创建的对象中获取bean(待补全详细)。</li><li>若2依旧未获取到并且允许提前创建早期对象则获取该bean的单例工厂，存在则创建并返回。 该方法试图获取bean对象。</li></ol></li><li>如果<code>getSingleton</code>未获取到。将bean置为创建状态。之后创建bean，创建过程将bean分成了单例，多例和其他三种情况来创建。</li></ol><h4 id="createBean创建对象："><a href="#createBean创建对象：" class="headerlink" title="createBean创建对象："></a>createBean创建对象：</h4><h5 id="调用resolveBeforeInstantiation"><a href="#调用resolveBeforeInstantiation" class="headerlink" title="调用resolveBeforeInstantiation:"></a>调用resolveBeforeInstantiation:</h5><p>调用来获取bean对象。遍历BeanPostProcessors如果是InstantiationAwareBeanPostProcessor接口调用处理器的postProcessBeforeInstantiation来获取对象，如果获取到了则调用处理器的postProcessAfterInitialization获取对象，并返回。</p><h5 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean:"></a>doCreateBean:</h5><p> 如果resolveBeforeInstantiation未获取到对象使用doCreateBean创建对象：</p><ol><li>createBeanInstance创建未初始化对象。如果beanDefinition没有FactoryMethodName则调用instantiateBean来创建对象，如果有则调用instantiateUsingFactoryMethod来创建对象。之后封装成BeanWrapper返回。</li><li>applyMergedBeanDefinitionPostProcessors调用。该方法找出MergedBeanDefinitionPostProcessor调用postProcessMergedBeanDefinition。(CommonAnnotationBeanPostProcessor,AutowiredAnnotationBeanPostProcessor,RequiredAnnotationBeanPostProcessor,ApplicationListenerDetector)AutowiredAnnotationBeanPostProcessor处理器为bean的beanDefinition添加了@Autowired和@Value注解属性，给该处理器的injectionMetadataCache属性添加需要注入信息对象的InjectionMetadata。 ApplicationListenerDetector往它的singletonNames属性中添加了该beanDefinition。</li><li>调用addSingletonFactory往工厂的singletonFactories属性中添加了该对象的早期对象来解决循环引用问题。</li><li>调用populateBean方法:<ol><li>查找所有的InstantiationAwareBeanPostProcessor。    (ConfigurationClassPostProcessor)，如果有处理器postProcessAfterInstantiation方法返回false则直接return<code>populateBean</code>方法。不对bean进行初始化修改。</li><li>调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues。AutowiredAnnotationBeanPostProcessor执行doResolveDependency来给当前处理的bean注入<code>@Autowired</code>和<code>@Value</code>的属性，取出之前缓存的该对象InjectionMetadata，调用inject来设置<code>@Autowired</code>依赖属性(期间调用doResolveDependency来获取真正需要注入的属性)。</li><li>doResolveDependency操作详解：<ol><li>先通过findAutowireCandidates方法获取所有的需要注入类型class文件(如果工厂中该对象已经被创建则返回对象)如果查找到的Candidates大于1则使用 determineAutowireCandidate 来进行过滤beanName。</li><li>首先使用determinePrimaryCandidate来查找(对象是否有@Primary注解)</li><li>determineHighestPriorityCandidate来查找(遍历获取这些bean的<code>@Priority</code>的优先级代号(数字越小优先级越高)，返回优先级最高的bean名称。)</li><li>最后遍历所有候选者找出beanName和注入beanName相同的。若有返回该beanName。</li><li>最后根据beanName获取bean对象(相互依赖的情况下会获取早期对象设置)。</li></ol></li><li>applyPropertyValues:<ol><li>通过BeanDefinitionValueResolver.resolveValueIfNecessary()获取/创建propertyValues中的对象。</li><li></li></ol></li></ol></li><li>调用initializeBean：<ol><li>如果该类实现了Aware接口(BeanNameAware,BeanClassLoaderAware,BeanFactoryAware)，给该类设置名称，类加载器，工厂等属性。</li><li>applyBeanPostProcessorsBeforeInitialization来执行所有bean后置处理器的postProcessBeforeInitialization。遍历过程中如果有一个处理器返回了null将会终止处理，返回最后处理对象。</li><li>invokeInitMethods执行初始化方法先执行实现InitializingBean接口的afterPropertiesSet方法，之后执行init方法。</li><li>applyBeanPostProcessorsAfterInitialization执行后置处理器postProcessAfterInitialization方法，和2逻辑相同。  </li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>整个bean的创建和初始化过程还是相当繁琐的步骤。bean的整个生命周期还是比较多样的，有很多BeanPostProcessor在bean创建前后以及初始化过程中都对bean进行了管理，包括bean全部创建后还有着回调功能，有着丰富的拓展功能。讲得可能不明了，希望对大家有所帮助。详细的demo可以去看博主的<a href="https://github.com/hiyouka/spring-cloud-resources" title="github" target="_blank" rel="noopener">github</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g0cutps3irj31kw0oy4qp.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在分析spring容器的创建过程中分析了bean的创建过程。由于创建过程步骤还是比较多的于是就新开一篇博客来详细分析下beanFactory的getBean方法做了哪些操作。分析的是通过beanType获取bean，因为根据type获取其实最终调用的也是根据beanName获取bean。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器创建源码解析</title>
    <link href="https://hiyouka.top/spring/ioc-analysis/"/>
    <id>https://hiyouka.top/spring/ioc-analysis/</id>
    <published>2019-01-25T07:17:00.000Z</published>
    <updated>2019-08-27T08:30:05.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wkhr0v9j30qo0dc7d2.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇博客是对Spring(5.0.7)的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多，讲的也可能比较枯燥。不过我相信我的分析对大家理解spring容器的整个工作原理还是有一些帮助的。<br><a id="more"></a></p><h3 id="无参构造器："><a href="#无参构造器：" class="headerlink" title="无参构造器："></a>无参构造器：</h3><p>&emsp;&emsp;先是调用它的无参构造函数，初始化一些信息。<br>&emsp;&emsp;无参构造函数中<code>new</code>了<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefiitionScanner</code>赋值给<code>reader</code>context的<code>scanner</code>属性。  </p><h4 id="newAnnotatedBeanDefinitionReader对象："><a href="#newAnnotatedBeanDefinitionReader对象：" class="headerlink" title="newAnnotatedBeanDefinitionReader对象："></a><code>new</code>AnnotatedBeanDefinitionReader对象：</h4><p>&emsp;&emsp;&emsp;&emsp;将该容器对象作为<code>BeanDefinitionRegistry</code>赋值给<code>registry</code>属性,并且<code>new</code>了一个<code>ConditionEvaluator</code>赋值给<code>conditionEvaluator</code>属性。之后调用<code>registerAnnotationConfigProcessors</code>方法将所有的annotation处理器注册进容器。  </p><h5 id="new-ConditionEvaluator"><a href="#new-ConditionEvaluator" class="headerlink" title="new ConditionEvaluator:"></a>new ConditionEvaluator:</h5><p>&emsp;&emsp;&emsp;&emsp;这是spring对该类的描述<code>Internal class used to evaluate {@link Conditional} annotations.</code>。可以看出这个类是<code>@Conditional</code>注解的一个解析器。在创建该类的时候利用<code>deduceBeanFactory</code>给该对象初始化了一个<code>DefaultListableBeanFactory</code>,并且该类是从容器中获取的。  </p><p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wn4k0pjj30ud05u74g.jpg" alt="img"></p><h5 id="AnnotationConfigUtils-registerAnnotationConfigProcessors："><a href="#AnnotationConfigUtils-registerAnnotationConfigProcessors：" class="headerlink" title="AnnotationConfigUtils.registerAnnotationConfigProcessors："></a>AnnotationConfigUtils.registerAnnotationConfigProcessors：</h5><p>&emsp;&emsp;&emsp;&emsp;该方法先是给容器的<code>beanFactory</code>初始化了<code>private Comparator&lt;Object&gt; dependencyComparator;</code>和<code>private AutowireCandidateResolver autowireCandidateResolver</code>两个属性；他们分别是用于bean的排序和解析自动注入<code>@Autowired</code>的；之后便开始注册一些spring内部的bean对象：<br><a name="divtop"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//spring检查容器中是否注入了这些bean 没有就创建简单的含有基本信息的BeanDefiintion对象注册</span></span><br><span class="line">   <span class="comment">// The bean name of the internally managed Configuration annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Autowired annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Required annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JSR-250 annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JPA annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME =</span><br><span class="line"><span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed @EventListener annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed EventListenerFactory.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_FACTORY_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册过程如下 详见DefaultListableBeanFactory的registerBeanDefinition</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">//do some thing .... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"> <span class="comment">// get beanDefinintion from cache</span></span><br><span class="line">oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">// if cache alredy has this beanName beanDefinition break</span></span><br><span class="line">    <span class="comment">//  some warn message or throw exception</span></span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// determine if create bean has started</span></span><br><span class="line"><span class="comment">//(判断方法很简单benaFactory中的Set&lt;String&gt;alreadyCreated是否已经被填充过)</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123; </span><br><span class="line">           <span class="comment">//lock beanDefinitionMap and put this beanDefinition to map</span></span><br><span class="line">           <span class="comment">//这里有个小细节他在添加元素进beanDefinitionNames时是直接创建了一个原先cache size+1的list</span></span><br><span class="line">           <span class="comment">//然后再将this beanDefinition name 放入list,最终改变beanDefinitionNames的为新创建list</span></span><br><span class="line">           <span class="comment">//if this beanDefinition is in manualSingletonNames,remove from list. why?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">this.beanDefinitionNames.add(beanName);</span><br><span class="line">this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">this.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果这个bean已经存在了单实例的对象则将其销毁</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&emsp;&emsp;至此<code>AnnotatedBeanDefinitionReaderd</code>对象创建完成  </p><h4 id="newClassPathBeanDefinitionScanner对象："><a href="#newClassPathBeanDefinitionScanner对象：" class="headerlink" title="newClassPathBeanDefinitionScanner对象："></a><code>new</code>ClassPathBeanDefinitionScanner对象：</h4><p>&emsp;&emsp;&emsp;&emsp;先是调用这个构造方法：  </p><p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wpn4k0kj30ps07ddg0.jpg" alt="img"><br>&emsp;&emsp;&emsp;&emsp;这里可以看出有3步操作<code>registerDefaultFilters</code>,<code>setEnvironment</code>,<code>setResourceLoader</code>  </p><h5 id="registerDefaultFilters方法"><a href="#registerDefaultFilters方法" class="headerlink" title="registerDefaultFilters方法:"></a>registerDefaultFilters方法:</h5><p>&emsp;&emsp;&emsp;&emsp;从名字我们不难看出这是创建默认过滤器的方法；<br>&emsp;&emsp;&emsp;&emsp;实际上是往该对象中添加了一个匹配<code>@Component</code>注解的AnnotationTypeFilter。spring对该类的解释如下：<br>&emsp;&emsp;&emsp;&emsp;<code>A simple filter which matches classes with a given annotation,checking inherited annotations as well.</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="comment">//代码如下：</span></span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="setEnvironment方法"><a href="#setEnvironment方法" class="headerlink" title="setEnvironment方法:"></a>setEnvironment方法:</h5><p>&emsp;&emsp;&emsp;&emsp;一样看名字我们就能知道这是设置环境信息的。就是将之前创建<code>AnnotatedBeanDefinitionReader</code>对象时获取的<code>StandardEnvironment</code>设置给该对象的<code>environment</code>属性。  </p><h5 id="setResourceLoader方法"><a href="#setResourceLoader方法" class="headerlink" title="setResourceLoader方法:"></a>setResourceLoader方法:</h5><p>&emsp;&emsp;&emsp;&emsp;该方法分别给该对象的<code>resourcePatternResolver</code>,<code>metadataReaderFactory</code>,<code>componentsIndex</code>属性初始化。<code>resourcePatternResolver</code>对象其实就是容器对象…. <code>metadataReaderFactory</code>是一个从容器<code>resourceCaches</code>属性拷贝过来的<code>ConcurrentHashMap</code>。<code>resourcePatternResolver</code>可能是在加载<code>META-INF/spring.components</code>这个配置文件吧。具体我也不太清楚。<br>&emsp;&emsp;&emsp;&emsp;<strong>至此spring容器的无参构造函数终于时调用完成了(😓)这只是简单的一步而且很多地方即使是知道了它在干什么还是不清楚他为什么这么做如果有更了解的大佬还望指教</strong>  </p><h3 id="register："><a href="#register：" class="headerlink" title="register："></a>register：</h3><p>&emsp;&emsp;将Config类注册进来，其实就是调用之前创建的<code>AnnotatedBeanDefinitionReader</code>对象的<code>register</code>方法将我们所传入的配置类注册到容器当中。我们可以直接看<code>AnnotatedBeanDefinitionReader</code>对象的<code>doRegisterBean</code>方法：<br>&emsp;&emsp;该方法先是创建了Config对象的定义信息<code>AnnotatedGenericBeanDefinition</code>。之后调用以下方法<code>shouldSkip</code>,<code>resolveScopeMetadata</code>,<code>generateBeanName</code>,<code>processCommonDefinitionAnnotations</code>,<code>applyScopedProxyMode</code>,<code>registerBeanDefinition</code>  </p><p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wq1o62gj30y00guwfe.jpg" alt="img"></p><h4 id="shouldSkip方法："><a href="#shouldSkip方法：" class="headerlink" title="shouldSkip方法："></a>shouldSkip方法：</h4><p>&emsp;&emsp;&emsp;&emsp;该方法先通过<code>isAnnotated</code>判断有没有<code>@Conditional</code>注解如果有则判断该类是否符合注入要求。<br>&emsp;&emsp;&emsp;&emsp; 我们先来看下他是如何判断有没有该注解的：<br>&emsp;&emsp;&emsp;&emsp;首先是<code>searchWithGetSemantics</code>方法来查出该类所有注解。<code>searchWithGetSemanticsInAnnotations</code>来做判断。如果该注解不是java包中的注解。则判断它是否是<code>@Conditional</code>注解或者任何时候都忽略的process。之后递归调用<code>searchWithGetSemantics</code>来看元注解有没有包含<code>@Conditional</code>的。以下为判断源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">    Class&lt;? extends Annotation&gt; currentAnnotationType = annotation.annotationType();</span><br><span class="line"><span class="keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (currentAnnotationType == annotationType ||</span><br><span class="line">currentAnnotationType.getName().equals(annotationName) ||</span><br><span class="line">processor.alwaysProcesses()) &#123;</span><br><span class="line">T result = processor.process(element, annotation, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (processor.aggregates() &amp;&amp; metaDepth == <span class="number">0</span>) &#123;</span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Repeatable annotations in container?</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currentAnnotationType == containerType) &#123;</span><br><span class="line"><span class="keyword">for</span> (Annotation contained : getRawAnnotationsFromContainer(element, annotation)) &#123;</span><br><span class="line">T result = processor.process(element, contained, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No need to post-process since repeatable annotations within a</span></span><br><span class="line"><span class="comment">// container cannot be composed annotations.</span></span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="resolveScopeMetadata方法"><a href="#resolveScopeMetadata方法" class="headerlink" title="resolveScopeMetadata方法:"></a>resolveScopeMetadata方法:</h4><p>&emsp;&emsp;&emsp;&emsp;获取该bean的scope(这里就不细讲spring bean的作用域了不懂的自行百度),ScopeMetadata对象的值默认为<code>singleton</code>,所以如果该类没有<code>@Scope</code>注解默认为单例的。  </p><h4 id="generateBeanName方法"><a href="#generateBeanName方法" class="headerlink" title="generateBeanName方法:"></a>generateBeanName方法:</h4><p>&emsp;&emsp;&emsp;&emsp;获取该bean的<code>@Component</code>注解标注的beanName,如果没有默认为类sortName。<br>获取类上的<code>@Component</code>注解步骤与第一步时获取<code>@Conditional</code>注解类似(递归获取注解-排除java注解)这里就不细讲了。</p><h4 id="processCommonDefinitionAnnotations方法"><a href="#processCommonDefinitionAnnotations方法" class="headerlink" title="processCommonDefinitionAnnotations方法:"></a>processCommonDefinitionAnnotations方法:</h4><p> &emsp;&emsp;&emsp;&emsp;对<code>@Lazy</code>,<code>@Primary</code>,<code>@DependsOn</code>,<code>@Role</code>,<code>@Description</code>的解析(这里提一下如果<code>@Lazy</code>没有的话默认是false,之前看到有人说默认懒加载显然时不正确的~)。丰富beanDefinition。比较简单不详细分析了,贴下源码:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">if (lazy != null) &#123;</span><br><span class="line"><span class="code">    abd.setLazyInit(lazy.getBoolean("value"));</span></span><br><span class="line">&#125;</span><br><span class="line">else if (abd.getMetadata() != metadata) &#123;</span><br><span class="line"><span class="code">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span></span><br><span class="line"><span class="code">    if (lazy != null) &#123;</span></span><br><span class="line"><span class="code">        abd.setLazyInit(lazy.getBoolean("value"));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">if (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line"><span class="code">    abd.setPrimary(true);</span></span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">if (dependsOn != null) &#123;</span><br><span class="line"><span class="code">    abd.setDependsOn(dependsOn.getStringArray("value"));</span></span><br><span class="line">&#125;</span><br><span class="line">if (abd instanceof AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="code">    AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span></span><br><span class="line"><span class="code">    AnnotationAttributes role = attributesFor(metadata, Role.class);</span></span><br><span class="line"><span class="code">    if (role != null) &#123;</span></span><br><span class="line"><span class="code">        absBd.setRole(role.getNumber("value").intValue());</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    AnnotationAttributes description = attributesFor(metadata, Description.class);</span></span><br><span class="line"><span class="code">    if (description != null) &#123;</span></span><br><span class="line"><span class="code">        absBd.setDescription(description.getString("value"));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="applyScopedProxyMode方法"><a href="#applyScopedProxyMode方法" class="headerlink" title="applyScopedProxyMode方法:"></a>applyScopedProxyMode方法:</h4><p>&emsp;&emsp;&emsp;&emsp;判断是否需要创建代理对象。如果需要调用<code>ScopedProxyCreator.createScopedProxy</code>方法创建。(待补全代理对象的创建过程…)  </p><h4 id="registerBeanDefinition方法"><a href="#registerBeanDefinition方法" class="headerlink" title="registerBeanDefinition方法:"></a>registerBeanDefinition方法:</h4><p>&emsp;&emsp;&emsp;&emsp;从方法名可以看出这部是真正的注册beanDefinition。真正调用的是容器中的BeanFactory(这里是<code>DefaultListableBeanFactory</code>)的<code>registerBeanDefinition</code>方法。首先验证beanDefinition的信息(具体我也没看懂在干什么)。之后判断该beanDefinition是否被注册过(若注册过符合条件覆盖之前的beanDefinition)。之后就是第一次注册该bean的操作(和调用无参构造函数注册过程一致<a href="#divtop">详情</a>。)<br>&emsp;&emsp;&emsp;&emsp;  </p><p><strong><code>register</code>方法分析到这里就结束了，其实做的事情就是将配置类注册到容器当中。</strong>  </p><h3 id="refresh："><a href="#refresh：" class="headerlink" title="refresh："></a>refresh：</h3><p>&emsp;&emsp;<code>refresh</code>是最重要的一步，进行了容器刷新以及bean创建。执行步骤比较多。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">prepareRefresh();</span><br><span class="line">// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">// Prepare the bean factory for use in this context.</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line">try &#123;</span><br><span class="line"><span class="code">    // Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="code">    postProcessBeanFactory(beanFactory);</span></span><br><span class="line"><span class="code">    // Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="code">    invokeBeanFactoryPostProcessors(beanFactory);</span></span><br><span class="line"><span class="code">    // Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="code">    registerBeanPostProcessors(beanFactory);</span></span><br><span class="line"><span class="code">    // Initialize message source for this context.</span></span><br><span class="line"><span class="code">    initMessageSource();</span></span><br><span class="line"><span class="code">    // Initialize event multicaster for this context.</span></span><br><span class="line"><span class="code">    initApplicationEventMulticaster();</span></span><br><span class="line"><span class="code">    // Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="code">    onRefresh();</span></span><br><span class="line"><span class="code">    // Check for listener beans and register them.</span></span><br><span class="line"><span class="code">    registerListeners();</span></span><br><span class="line"><span class="code">    // Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="code">    finishBeanFactoryInitialization(beanFactory);</span></span><br><span class="line"><span class="code">    // Last step: publish corresponding event.</span></span><br><span class="line"><span class="code">    finishRefresh();</span></span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line"><span class="code">    // Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line"><span class="code">    destroyBeans();</span></span><br><span class="line"><span class="code">    // Reset 'active' flag.</span></span><br><span class="line"><span class="code">    cancelRefresh(ex);</span></span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line"><span class="code">    // Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="code">    // might not ever need metadata for singleton beans anymore...</span></span><br><span class="line"><span class="code">    resetCommonCaches();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="prepareRefresh-："><a href="#prepareRefresh-：" class="headerlink" title="prepareRefresh()："></a>prepareRefresh()：</h4><p>&emsp;&emsp;&emsp;&emsp; 进行容器的预刷新工作。这步还是比较简单的。先是将容器置为启动状态。之后调用<code>initPropertySources</code>(该方法为空方法，提供给子类的覆盖)<br>最后调用<code>validateRequiredProperties</code>来验证是否包含一些必要参数(这里必要参数依旧为空)。  </p><h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory():"></a>obtainFreshBeanFactory():</h4><p>&emsp;&emsp;&emsp;&emsp; 对<code>beanFactory</code>进行刷新工作。先是调用<code>refreshBeanFactory</code>,使用CAS判断工厂是否已经刷新(已刷新抛异常),之后给工厂bean一个序列化id，<br>并将工厂对象放入缓存(由序列化id映射)。最后返回工厂bean(调用容器无参构造函数创建的<code>DefaultListableBeanFactory</code>对象);  </p><h4 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory):"></a>prepareBeanFactory(beanFactory):</h4><p>进行<code>beanFactory</code>的准备工作:</p><ol><li>给<code>beanFactory</code>添加类加载器，表达式解析器，属性编辑器注册器， <code>ApplicationContextAwareProcessor</code>。</li><li>忽略某些类的自动注入(这些接口大多为Spring为实现类注入bean的功能接口，例如：ApplicationContextAware)。</li><li>指定<code>BeanFactory</code>,<code>ResourceLoader</code>,<code>ApplicationEventPublisher</code>,<code>ApplicationContext</code>这些类型自动注入时的类(除<code>beanFactory</code>为当前<code>beanFactory</code>其余都为当前容器)</li><li>为工厂注入一些环境配置信息(beanName分别为environment、systemProperties、systemEnvironment)</li></ol><h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory:"></a>postProcessBeanFactory:</h4><p>&emsp;&emsp;&emsp;&emsp;该方法时BeanFactory初始化之后再进行后续的一些BeanFactory操作。对于<code>AnnotationConfigApplicationContext</code>这是父类的一个空方法。在SpringBoot创建的另外两个web容器的时候(<code>AnnotationConfigServletWebServerApplicationContext</code>、<code>AnnotationConfigReactiveWebServerApplicationContext</code>)会重写该方法。以后可能会出个SpringBoot原理分析系列详细会讲到这两个容器的创建及准备。</p><h4 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors:"></a>invokeBeanFactoryPostProcessors:</h4><p><code>invokeBeanFactoryPostProcessors</code>方法比较关键。该方法做了以下步骤：</p><ol><li>执行ConfigurationClassPostProcessor,这个处理器主要来解析配置类(分为完整配置类和精简配置类，这里只详解带<code>@Configuration</code>注解的完整配置类)，主要用于注册bean。</li><li>执行其他BeanFactoryPostProcessor。(分为BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor两种接口)</li></ol><h5 id="执行ConfigurationClassPostProcessor："><a href="#执行ConfigurationClassPostProcessor：" class="headerlink" title="执行ConfigurationClassPostProcessor："></a>执行ConfigurationClassPostProcessor：</h5><p> 该方法主要执行了步骤：</p><ol><li><code>ConfigurationClassParser</code>的parse方法：<ol><li>获取<code>@PropertySource</code>注解信息(之后所有的获取注解信息都是分析<code>shouldSkip</code>提到的searchWithGetSemantics方法完成的)，使用processPropertySource解析添加配置文件信息。处理过程大致是先创建PropertySource(创建的时候调用loadProperties读取配置文件信息)。之后将该配置文件信息添加到beanFactory的<code>environment</code>bean对象中去。</li><li>获取<code>@ComponentScans</code>注解信息(若未获取到则为配置类的目录)。使用<code>ComponentScanAnnocationParser</code>来解析需要注册的bean，之后调用<code>ClassPathBeanDefinitionScanner</code>的doScan来将beanDefinition注册进容器。doScan做的事情就是扫包获取指定包的所有class文件并筛选有<code>@Component</code>并且<code>@Conditional</code>匹配的class。BeanDefinition注册过程就是之前提到的registerBeanDefinition方法。之后遍历获取到的BeanDefinitions执行parse。<br>操作将注册进来的Bean里的<code>@PropertySource</code>,<code>@ComponentScans</code>等注解的信息注册进来(递归注册)。</li><li><code>@Import</code>注解解析。processImports方法来执行该操作。将所有该注解引入的类注册到容器当中。使用collectImports方法递归查找该类下所有的注解中包含的<code>@Import</code>引入的对象。之后便是遍历处理操作：<ol><li>如果引入对象是<code>ImportSelector</code>实现类，实例化该类。如果该类实现了<code>Aware</code>接口先给该类初始化这些属性(包含<code>BeanClassLoaderAware</code>,<code>BeanFactoryAware</code>,<code>EnvironmentAware</code>,<code>ResourceLoaderAware</code>)。之后判断如果该类实现类DeferredImportSelector接口就将其放入<code>deferredImportSelectors</code>后续处理。否则调用selectImports获取import对象并执行processImports递归。</li><li>如果引入对象是<code>ImportBeanDefinitionRegistrar</code>实现类，和之前一样先实例化再根据<code>Aware</code>初始化。最后将实例化后的类添加到带有<code>@Import</code>类的<code>ConfigurationClass</code>的<code>importBeanDefinitionRegistrars</code>属性中以便后续操作。</li><li>其他情况将其放入<code>ConfigurationClassParser</code>的<code>importStack</code>的<code>imports</code>缓存(用于判断该类是否需要解析)。生成该类的<code>ConfigurationClass</code>(带有<code>importedBy</code>属性)。</li></ol></li><li><code>@ImportResource</code>和第一步类似这个引入的是spring的配置类。往带有该注解的<code>ConfigurationClass</code>的<code>importedResources</code>属性添加该</li><li><code>retrieveBeanMethodMetadata</code>，解析该类所有带有<code>@Bean</code>的方法将其添加到该类的ConfigurationClass。</li><li><code>processInterfaces</code>，解析注入类中的所有接口中的default方法是否包含<code>@Bean</code>的，如果有就创建一个BeanMethod添加到该类的ConfigurationClass以便下一步来注册该对象。这两个方法查找了所有的<code>@Bean</code>Method。          </li><li>添加父类class到配置类中进行注册操作，和之前的parse操作相同。</li><li>将当前解析类的<code>ConfigurationClass</code>放入<code>ConfigurationClassParser</code>的configurationClasses属性中，为之后解析做准备。</li><li><code>processDeferredImportSelectors</code>处理3中放入<code>deferredImportSelectors</code>缓存中的DeferredImportSelector。调用所有的selectors的selectImports方法来获取所有导入类并封装成<code>SourceClass</code>列表再去调用processImports来递归。(这么多操作实际目的就是将所有的@Import生成<code>ConfigurationClass</code>或者放入<code>importBeanDefinitionRegistrars</code>为之后loadBeanDefinitions做准备)</li></ol></li><li><code>ConfigurationClassBeanDefinitionReader</code>的loadBeanDefinitions：<ol><li>遍历<code>ConfigurationClass</code>执行loadBeanDefinitionsForConfigurationClass。</li><li>判断该<code>ConfigurationClass</code>是否是导入的(带有<code>importedBy</code>属性)，如果是将给类注册到beanFactory</li><li>解析该<code>ConfigurationClass</code>带有<code>@Bean</code>的方法生成beanDefinition(该定义信息除了有Lazy等属性外还有factoryBeanName和factoryMethodName)并注册到容器当中。</li><li>从importedResources属性中注册beanDefinition。读取配置文件信息获取beanDefinition并注册。</li><li>从1.3.2中放入<code>importBeanDefinitionRegistrars</code>属性中调用ImportBeanDefinitionRegistrar的registerBeanDefinitions直接注册到容器中。</li></ol></li></ol><h5 id="执行BeanFactoryPostProcessor："><a href="#执行BeanFactoryPostProcessor：" class="headerlink" title="执行BeanFactoryPostProcessor："></a>执行BeanFactoryPostProcessor：</h5><p>BeanFactoryPostProcessor排序执行：</p><ol><li>获取BeanDefinitionRegistryPostProcessor执行处理(postProcessBeanDefinitionRegistry)。之后执行回调(postProcessBeanFactory)</li><li>获取BeanFactoryPostProcessor执行执行前置处理(postProcessBeanFactory)。之后执行后置处理(postProcessBeanFactory)</li><li>清除beanFactory缓存，清除<code>mergedBeanDefinitions</code>的未创建对象的定义信息。</li></ol><h4 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors:"></a>registerBeanPostProcessors:</h4><p>添加BeanPostProcessors：</p><ol><li>添加BeanPostProcessorChecker处理器。</li><li>获取所有的BeanPostProcessors排序并添加。 registerBeanPostProcessors过程很简单就是将该处理器对象放入beanFactory，这个过程会通过<code>getBean</code>创建处理器对象。</li><li>添加ApplicationListenerDetector处理器。</li></ol><p>执行顺序：</p><ol><li>实现PriorityOrdered接口。</li><li>实现Ordered接口。</li><li>没有实现PriorityOrdered和Ordered接口的。</li><li>实现MergedBeanDefinitionPostProcessor接口的处理器。</li></ol><h4 id="initMessageSource："><a href="#initMessageSource：" class="headerlink" title="initMessageSource："></a>initMessageSource：</h4><p>国际化配置的信息。</p><h4 id="initApplicationEventMulticaster："><a href="#initApplicationEventMulticaster：" class="headerlink" title="initApplicationEventMulticaster："></a>initApplicationEventMulticaster：</h4><p>初始化容器的事件广播器。如果容器中没有<code>applicationEventMulticaster</code>bean对象，创建一个SimpleApplicationEventMulticaster时间广播器并注册进beanFactory。</p><h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh:"></a>onRefresh:</h4><p>可以重写的模板方法，以添加特定于上下文的刷新工作。对于AnnotationConfigApplicationContext这是个空方法。</p><h4 id="registerListeners："><a href="#registerListeners：" class="headerlink" title="registerListeners："></a>registerListeners：</h4><p>检查监听器bean并注册它们：</p><ol><li>注册静态指定的侦听器。(添加到applicationListeners集合中)</li><li>从beanFactory获取ApplicationListener类型的beanNames并注册他们。</li><li>执行早期容器事件。</li></ol><h4 id="finishBeanFactoryInitialization："><a href="#finishBeanFactoryInitialization：" class="headerlink" title="finishBeanFactoryInitialization："></a>finishBeanFactoryInitialization：</h4><p>将实例化的beanDefinition进行实例化：</p><ol><li>如果容器中没有字符串解析器，new字符串解析器(使用容器Environment中的解析器来解析,默认是PropertySourcesPropertyResolver)。</li><li>开启允许缓存所有的beanDefinition并且将所有的beanDefinitions放入冻结配置情况的缓存中。</li><li>使用beanFactory的<code>preInstantiateSingletons</code>来实例化所有的beanDefinition。<ol><li>遍历所有beanDefinition，获取该bean组合的beanDefinition。如果该bean需要工厂创建的对象，先使用getBean获取工厂对象再getBean获取工产对象。不是工厂对象直接调用getBean。(getBean起到创建对象作用。创建对象时会调用BeanPostProcessor。详细看<a href="https://hiyouka.top/spring/getBean/">这篇博客</a>这篇博客)</li><li>遍历所有的beanDefinition，getSingleton从缓存中获取之前创建的Bean。如果该bean实现了SmartInitializingSingleton接口，执行接口方法afterSingletonsInstantiated。</li></ol></li></ol><h4 id="finishRefresh："><a href="#finishRefresh：" class="headerlink" title="finishRefresh："></a>finishRefresh：</h4><ol><li>清除上下文级资源缓存（这里是资源reader对象）。</li><li>为此上下文初始化生命周期处理器。（beanName：lifecycleProcessor），如果没有获取到默认注册DefaultLifecycleProcessor。</li><li>调用生命周期处理器的onRefresh：<ol><li>获取beanFactory中所有实现Lifecycle接口的beanName，遍历，筛选出实现Lifecycle接口的必须在之前被实例化了或者实现SmartLifecycle接口。（过滤lifecycleProcessor）</li><li>遍历1获取的所有Lifecycle中实现SmartLifecycle接口并且该类的isAutoStartup方法为true的对象。</li><li>遍历2中获取的Lifecycle执行start方法。</li></ol></li><li>添加ContextRefreshedEvent的</li><li>向LiveBeansView中注册该容器。（JMX的相关操作）</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>以上就是AnnotationConfigApplicationContext的创建过程。这里解析的都是基于注解的解析方式，由兴趣的小伙伴还可以看下基于xml的解析(应该只有Resource读取有所差异)，之后我会自己实现一个可以扩展的简单容器（项目名字已经起好了叫seed😁），应该还会整合这个容器和netty（还在学习中…）实现一个异步的Controller层的框架，希望我的文章能帮到大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g06wkhr0v9j30qo0dc7d2.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这篇博客是对Spring(5.0.7)的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多，讲的也可能比较枯燥。不过我相信我的分析对大家理解spring容器的整个工作原理还是有一些帮助的。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
</feed>
