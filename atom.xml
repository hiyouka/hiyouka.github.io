<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hiyouka</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiyouka.top/"/>
  <updated>2019-03-25T05:22:10.662Z</updated>
  <id>https://hiyouka.top/</id>
  
  <author>
    <name>hiyouka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis源码分析(结合SpringBoot自动装配)</title>
    <link href="https://hiyouka.top/mybatis/mybatis-spring/"/>
    <id>https://hiyouka.top/mybatis/mybatis-spring/</id>
    <published>2019-03-20T07:54:20.000Z</published>
    <updated>2019-03-25T05:22:10.662Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g19bzb8qg4j309q02gq2s.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;之前阅读了spring的ioc容器初始化源码感觉阅读源码还是一件很有意义的事情,除了能了解它们底层的实现方式,还能学习它们使用的巧妙设计模式,于是想着再阅读一下常用框架mybatis的原理。这次为了更清晰的记录框架结构采用了画图的方式,也方便了以后复习回忆。(<a href="https://github.com/hiyouka/spring-cloud-resources" target="_blank" rel="noopener">项目demo地址</a>)<br><a id="more"></a></p><h3 id="注册mapper接口类"><a href="#注册mapper接口类" class="headerlink" title="注册mapper接口类"></a>注册mapper接口类</h3><p>&emsp;&emsp;首先从MapperScan注解开始它引入了一个类MapperScannerRegistrar。该类实现了ImportBeanDefinitionRegistrar接口,所以在spring容器启动的时候会在ConfigurationClassBeanDefinitionReader调用loadBeanDefinitions的时候调用该类的registerBeanDefinitions方法将@MapperScan配置的路径中的class类添加到spring容器当中(spring源码解析中有关于容器启动的过程解析)。</p><ol><li>该类的registerBeanDefinitions方法首先是创建了一个ClassPathMapperScanner类(继承了spring的扫包类ClassPathBeanDefinitionScanner)。</li><li>给ClassPathMapperScanner设置了一些注册过滤器(根据@MapperScan注解的markerInterface属性添加过滤器,还会添加一个始终为true的过滤器)。</li><li>调用父类的doScan方法将bean定义信息注册到容器当中。</li><li>通过processBeanDefinitions方法,主要就是将该类定义信息封装成MapperFactoryBean(实现spring的FactoryBean),还会给bean定义信息添加ConstructorArgumentValues让spring之后创建该MapperFactoryBean的时候调用以该接口class为参数的构造函数来创建对象。容器对象实例化getBean的时候将会调用MapperFactoryBean的getObject。<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1bcwin1ugj30s708zjrj.jpg" alt="img"><br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g19cyry8qtj30gm03d745.jpg" alt="img"></li></ol><h3 id="mapper接口类的创建"><a href="#mapper接口类的创建" class="headerlink" title="mapper接口类的创建"></a>mapper接口类的创建</h3><p>&emsp;&emsp;在第一个Mapper接口类创建的时候会创建sqlSessionFactory,sqlSessionTemplate(如果没有手动注册的话)。这些类是由mybatis的自动配置类来注册创建的,之后会详细分析。创建Mapper类的实例就是调用MapperFactoryBean的getObject,最终调用的是MapperRegistry的getMapper,从下图可以看出来实现原理就是使用java的动态代理来创建一个代理对象,代理类为MapperProxy类。<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1ae59ihc8j30pi05jq32.jpg" alt="img"><br>&emsp;&emsp;在MapperFactoryBean创建完成之后会执行初始化方法(DaoSupport实现了InitializingBean接口),初始化方法中调用了checkDaoConfig和initDao方法。<br>MapperFactoryBean重写了checkDaoConfig方法。MapperRegistry类管理着mapper类和MapperProxyFactory映射的map集合。<br>checkDaoConfig方法：</p><ol><li>MapperAnnotationBuilder的loadXmlResource获取xml文件资源(这里要提一下, mybatis直接通过mapper文件路径寻找xml,如果mapper接口与xml路径不一致会导致无法读取到xml文件而且最坑的是它把异常给捕获了,即使找不到启动也不会报错,而会在你调用mapper方法的时候再报错。。。)获取到xml资源创建创建loadXmlResource对象<ol><li>createDocument 读取xml的document对象并封装在XPathParser对象中。</li><li>configurationElement,利用XpathParser解析mapper,resultMap,sql等dom节点信息。</li><li>buildStatementFromContext 读取sql语句(insert/update/delete/select节点),封装成MappedStatement对象并添加到Configuration中。</li></ol></li><li>MapperAnnotationBuilder的parseStatement方法将基于注解的sql信息封装到成MappedStatement添加到Configuration。<br>mybatis初始化动态sql图解：<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1bplmlsgkj30uy0kv770.jpg" alt="img"></li></ol><h3 id="mybatis的自动装配-SpringBoot"><a href="#mybatis的自动装配-SpringBoot" class="headerlink" title="mybatis的自动装配(SpringBoot)"></a>mybatis的自动装配(SpringBoot)</h3><p>&emsp;&emsp;SpringBoot首先在启动的时候会读取项目下的”META-INF/spring.factories”路径的自动配置类,过滤器,监听器,ApplicationContextInitializer等。mybatis的自动装配就引入了MybatisAutoConfiguration类。<br>&emsp;&emsp;分析mybatis的自动装配前需要来接下@EnableAutoConfiguration注解,SpringBoot的启动注解@SpringBootApplication就自带该注解,该注解引入了两个类分别是AutoConfigurationImportSelector,AutoConfigurationPackages.Registrar。</p><ol><li>AutoConfigurationImportSelector: 该类实现了DeferredImportSelector接口(继承ImportSelector接口),所以在spring进行容器刷新的时候会调用该类的selectImports方法将一些组件注册进容器当中。<br>这个类的selectImports方法：<ol><li>从项目中读取”META-INF/spring-autoconfigure-metadata.properties”文件的内容(自动装配引入的类)。</li><li>从缓存中获取EnableAutoConfiguration类的类名(SpringBoot启动时读取的自动配置类);</li><li>移除配置的忽略类(@SpringBootApplication/@EnableAutoConfiguration的exclude属性配置)</li><li>使用过滤器筛选自动配置类。SpringBoot默认注册了OnClassCondition过滤器,在spring-autoconfigure-metadata.properties的配置文件中需要配置ConditionalOnClass对应的value就是OnClassCondition类去判断的类)该过滤器筛选掉ClassLoader中缺失所需类的自动装配类。</li></ol></li><li>AutoConfigurationPackages.Registrar:将AutoConfigurationPackages类注册入容器,目前还不清楚该类的作用。官方描述：Class for storing auto-configuration packages for reference later (e.g. by JPA entity scanner).<br>SpringBoot读取自动装配类流程图如下：<br><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g1csxz0lraj30xf0dy76r.jpg" alt="img"></li></ol><p>&emsp;&emsp;之后在容器刷新创建类的时候就会自动配置sqlSessionFactory,sqlSessionTemplate类。mybatis的自动装配类中还有一个类MapperScannerRegistrarNotFoundConfiguration,当检测到容器中没有MapperFactory时就会扫描项目中Mapper的类将其作为MapperFactory注册进容器。也就是表示可以不添加@MapperScan注解，只在接口类上加上@Mapper注解就可以注入容器当中了。</p><h3 id="mapper接口方法的执行："><a href="#mapper接口方法的执行：" class="headerlink" title="mapper接口方法的执行："></a>mapper接口方法的执行：</h3><p>&emsp;&emsp;第二部分中提到创建在容器当中的Mapper接口类是一个MapperProxy的代理类。在我们调用Mapper接口的方法时就会执行MapperProxy的invoke方法。</p><p>AutoConfigurationGroup  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g19bzb8qg4j309q02gq2s.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;之前阅读了spring的ioc容器初始化源码感觉阅读源码还是一件很有意义的事情,除了能了解它们底层的实现方式,还能学习它们使用的巧妙设计模式,于是想着再阅读一下常用框架mybatis的原理。这次为了更清晰的记录框架结构采用了画图的方式,也方便了以后复习回忆。(&lt;a href=&quot;https://github.com/hiyouka/spring-cloud-resources&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目demo地址&lt;/a&gt;)&lt;br&gt;
    
    </summary>
    
      <category term="mybatis" scheme="https://hiyouka.top/categories/mybatis/"/>
    
    
      <category term="mybatis,SpringBoot" scheme="https://hiyouka.top/tags/mybatis-SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>实现一个ioc容器</title>
    <link href="https://hiyouka.top/seed/ioc/"/>
    <id>https://hiyouka.top/seed/ioc/</id>
    <published>2019-03-09T11:19:00.000Z</published>
    <updated>2019-03-25T05:22:10.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g0yw2rag7nj30ha09qgmf.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;之前花了一些时间阅读了一部分spring源码,于是想自己实现一个类似spring容器功能的框架。利用工作之余花了半个月时间总算是写出了一个简单的容器seed。功能模块实现思想和spring类似，希望能够更好的帮助小伙伴了解spring的原理(<a href="https://github.com/hiyouka/seed-framework" target="_blank" rel="noopener">github地址</a>)。<br><a id="more"></a></p><h3 id="容器的刷新"><a href="#容器的刷新" class="headerlink" title="容器的刷新"></a>容器的刷新</h3><p>&emsp;&emsp; seed容器是通过invokeBeanFactoryPostProcessors方法来执行提前注册在容器当中的处理器。该处理的功能就是解析加载进来的配置类。解析配置类上的<code>@ComponentScan</code>,<code>@Import</code>和<code>@Bean</code>注解。将所有<code>@Component</code>标识的组件加载到容器当中并形成bean的定义信息。 该方法通过扫描配置的路径来读取所有的class文件将其封装成Resource对象。之后解析class文件的信息读取到注解信息进行再解析。通过Resource信息来生成BeanDefinition，我这里解析class文件时使用的cglib包中带的asm组件使用里面的ClassReader类来解析class文件再进一步封装成bean的定义信息。<br>&emsp;&emsp;之后调用registerBeanPostProcessor方法将所有的BeanPostProcessor实例化添加到容器当中为之后的bean创建准备工作。<br>&emsp;&emsp;最后就是将所有的单例，非懒加载的bean创建到容器当中。在创建bean时会有一些前置后置处理流程。通过实现BeanPostProcessor接口可以来自定义bean创建时的前置后置处理方法。懒加载对象和多例对象会在调用getBean的时候才去进行创建对象。在getBean的时候将单例对象缓存起来，之后进行bean的获取工作时都是从缓存中获取。在以类型进行getBean的时候会先更具类型查出所有的bean名称，并生成一个类型对应名称的缓存，加快之后获取的效率。根据类型获取单个bean时，或检验bean上有没有@Primary注解。选择由@Primary注解的对象返回。如果都没有则会抛异常。这一点和Spring的实现类似。创建bean就是使用简单的反射调用构造函数来生成对象。在处理@Bean注解的时候和spring有点差异，spring不会将@Bean导入的对象当作配置类继续处理，而我这边的实现会将其作为配置类继续处理。即：在@Bean导入的类上也可以引入其他类。</p><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p>&emsp;&emsp; seed的生命周期和spring容器几乎一致。</p><ol><li>首先是创建初步的bean对象。</li><li>之后再进行bean的依赖注入工作(该功能待完成)。</li><li>调用beanPostProcessor的前置处理方法。</li><li>如果该bean实现Initialization接口那么会先执行afterPropertiesSet方法。之后执行init方法(通过@InitMethod注解来标记init方法)</li><li>调用beanPostProcessor的后置处理方法。</li></ol><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ol><li>通过实现seed的BeanFactoryPostProcessor接口可以再容器扫包之后往容器中添加一些bean定义信息。</li><li>实现EnvironmentAware接口可以往类中添加Environment环境变量类。从该类中可以获取环境变量信息，jvm参数信息，以及使用@PropertySources导入的配置文件数据。</li><li>实现BeanFactoryAware接口可以获取容器的beanFactory。</li><li>实现ApplicationContextAware接口可以获取到ApplicationContext容器。</li><li>容器中默认注册了环境变量信息，以及配置的读取配置文件的数据信息。通过getBean可获取容器中的组件来获取上述信息。</li></ol><p>这些功能都是基于一个后置处理器来实现的。再bean的创建当中如果该bean实现以上接口则会将以上对相应的信息通过接口方法注入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp; 这个项目自己结合spring源码写出来的缩减版ioc容器。其实每一步的程序实现都是比较简单的。难点就在于通用性接口设计，功能抽象等（其实这些我都是模仿的spring😓）。之后这个项目还会加上依赖注入，aop以及web服务的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g0yw2rag7nj30ha09qgmf.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;之前花了一些时间阅读了一部分spring源码,于是想自己实现一个类似spring容器功能的框架。利用工作之余花了半个月时间总算是写出了一个简单的容器seed。功能模块实现思想和spring类似，希望能够更好的帮助小伙伴了解spring的原理(&lt;a href=&quot;https://github.com/hiyouka/seed-framework&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github地址&lt;/a&gt;)。&lt;br&gt;
    
    </summary>
    
      <category term="seed" scheme="https://hiyouka.top/categories/seed/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="seed" scheme="https://hiyouka.top/tags/seed/"/>
    
  </entry>
  
  <entry>
    <title>Spring对象创建初始化分析</title>
    <link href="https://hiyouka.top/spring/getBean/"/>
    <id>https://hiyouka.top/spring/getBean/</id>
    <published>2019-02-20T07:17:00.000Z</published>
    <updated>2019-03-25T05:22:10.678Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g0cutps3irj31kw0oy4qp.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;在分析spring容器的创建过程中分析了bean的创建过程。由于创建过程步骤还是比较多的于是就新开一篇博客来详细分析下beanFactory的getBean方法做了哪些操作。分析的是通过beanType获取bean，因为根据type获取其实最终调用的也是根据beanName获取bean。<br><a id="more"></a></p><h3 id="resolveNamedBean："><a href="#resolveNamedBean：" class="headerlink" title="resolveNamedBean："></a>resolveNamedBean：</h3><p>这个方法的目的是根据类型获取beanNames：</p><ol><li><p>getBeanNamesForType：</p><ol><li>先从缓存中获取该类型的所有beanName。</li><li><p>如果1没有获取到执行doGetBeanNamesForType：</p><ol><li>遍历所有的bean查找符合该类型的的单例bean和单例bean工厂对象。</li><li>从<code>manualSingletonNames</code>(容器创建时无参构造函数初始化的bean)中获取符合的单例bean和单例bean工厂对象。（这边要注意在返回工厂bean名称时需要加上<code>&amp;</code>)</li><li>返回所有该对象或对象工厂的集合。</li></ol></li><li><p>将获取的beanNames放入缓存中。</p></li></ol></li><li>筛选出这些beanName中不在beanDefinitionMap集合中或者允许自动注入的bean。</li><li>如果1中获取的beanNames大于一个，获取需要的beanName：(在这一步的时候已经调用getBean(beanName获取了对象))<ol><li>determinePrimaryCandidate来解析<code>@Primary</code>信息。如果只有一个beanName的定义信息被注册到该beanFactory或者该beanFactory的<code>parentBeanFactory</code>中 并且该beanName的定义信息为Primary。返回该beanName。</li><li>如果1没获取到determineHighestPriorityCandidate获取。遍历获取这些bean的<code>@Priority</code>的优先级代号(数字越小优先级越高)，返回优先级最高的bean名称。</li></ol></li><li>获取到beanName后通过beanName返回包含该对象的NamedBeanHolder。</li></ol><p>resolveNamedBean的操作源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="comment">//if not allow cache all bean or allowEagerInit ? 这个条件看不懂</span></span><br><span class="line">    <span class="comment">//isConfigurationFrozen if is true mean this context init finish</span></span><br><span class="line">    <span class="comment">//get bean name from beanDefinitionNames and manualSingletonNames</span></span><br><span class="line"><span class="keyword">if</span> (!isConfigurationFrozen() || type == <span class="keyword">null</span> || !allowEagerInit) &#123;</span><br><span class="line"><span class="keyword">return</span> doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if allow cache all bean get bean name from cache first(isConigurationFrozen is true)</span></span><br><span class="line">Map&lt;Class&lt;?&gt;, String[]&gt; cache = // includeNonSingletons : 是否包含非单例对象</span><br><span class="line">(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);</span><br><span class="line">String[] resolvedBeanNames = cache.get(type);</span><br><span class="line"><span class="keyword">if</span> (resolvedBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if can not get this bean type from cache ,get bean name from beanDefinitionNames and manualSingletonNames</span></span><br><span class="line">resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// here is some safe check:  such as whether or not this bean classLoader to the beanFatory classLoader(具体我也不太清楚)</span></span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">cache.put(type, resolvedBeanNames); <span class="comment">// put this beanname to cache</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">`doGetBeanNamesForType`操作源码： </span><br><span class="line">        </span><br><span class="line">```php</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">List</span>&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Check all bean definitions.</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : this.beanDefinitionNames) &#123;</span><br><span class="line">    <span class="comment">// Only consider bean as eligible if the bean name</span></span><br><span class="line">    <span class="comment">// is not defined as alias for some other bean.</span></span><br><span class="line">    <span class="keyword">if</span> (!isAlias(beanName)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">// Only check bean definition if it is complete.</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">    (mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">    !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">    boolean isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">    BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">    boolean matchFound =</span><br><span class="line">    (allowEagerInit || !isFactoryBean ||</span><br><span class="line">    (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">    (includeNonSingletons ||</span><br><span class="line">    (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">    isTypeMatch(beanName, type);</span><br><span class="line">    <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line">    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">    matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">    result.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CannotLoadBeanClassException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check manually registered singletons too.</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : this.manualSingletonNames) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">    <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">    result.add(beanName);</span><br><span class="line">    <span class="comment">// Match found for this bean: do not match FactoryBean itself anymore.</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In case of FactoryBean, try to match FactoryBean itself next.</span></span><br><span class="line">    beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Match raw bean instance (might be raw FactoryBean).</span></span><br><span class="line">    <span class="keyword">if</span> (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">    result.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br></pre></td></tr></table></figure></p><h3 id="getBean-beanName"><a href="#getBean-beanName" class="headerlink" title="getBean(beanName):"></a>getBean(beanName):</h3><p>&emsp;&emsp;&emsp;&emsp;该方法通过beanName获取bean，实际操作在<code>doGetBean</code>方法中：  </p><ol><li>该方法先是判断该bean是否被注册(工厂bean需去除<code>&amp;</code>),之后调用<code>getSingleton</code>试图获取bean实例:<ol><li>从单例对象缓存中获取bean。</li><li>若1未获取到并且该对象正在创建则锁定单例缓存从早期创建的对象中获取bean(待补全详细)。</li><li>若2依旧未获取到并且允许提前创建早期对象则获取该bean的单例工厂，存在则创建并返回。 该方法试图获取bean对象。</li></ol></li><li>如果<code>getSingleton</code>未获取到。将bean置为创建状态。之后创建bean，创建过程将bean分成了单例，多例和其他三种情况来创建。</li></ol><h4 id="createBean创建对象："><a href="#createBean创建对象：" class="headerlink" title="createBean创建对象："></a>createBean创建对象：</h4><h5 id="调用resolveBeforeInstantiation"><a href="#调用resolveBeforeInstantiation" class="headerlink" title="调用resolveBeforeInstantiation:"></a>调用resolveBeforeInstantiation:</h5><p>调用来获取bean对象。遍历BeanPostProcessors如果是InstantiationAwareBeanPostProcessor接口调用处理器的postProcessBeforeInstantiation来获取对象，如果获取到了则调用处理器的postProcessAfterInitialization获取对象，并返回。</p><h5 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean:"></a>doCreateBean:</h5><p> 如果resolveBeforeInstantiation未获取到对象使用doCreateBean创建对象：</p><ol><li>createBeanInstance创建未初始化对象。如果beanDefinition没有FactoryMethodName则调用instantiateBean来创建对象，如果有则调用instantiateUsingFactoryMethod来创建对象。之后封装成BeanWrapper返回。</li><li>applyMergedBeanDefinitionPostProcessors调用。该方法找出MergedBeanDefinitionPostProcessor调用postProcessMergedBeanDefinition。(CommonAnnotationBeanPostProcessor,AutowiredAnnotationBeanPostProcessor,RequiredAnnotationBeanPostProcessor,ApplicationListenerDetector)AutowiredAnnotationBeanPostProcessor处理器为bean的beanDefinition添加了@Autowired和@Value注解属性，给该处理器的injectionMetadataCache属性添加需要注入信息对象的InjectionMetadata。 ApplicationListenerDetector往它的singletonNames属性中添加了该beanDefinition。</li><li>调用addSingletonFactory往工厂的singletonFactories属性中添加了该对象的早期对象来解决循环引用问题。</li><li>调用populateBean方法:<ol><li>查找所有的InstantiationAwareBeanPostProcessor。(ConfigurationClassPostProcessor)，如果有处理器postProcessAfterInstantiation方法返回false则直接return<code>populateBean</code>方法。不对bean进行初始化修改。</li><li>调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues。AutowiredAnnotationBeanPostProcessor执行doResolveDependency来给当前处理的bean注入<code>@Autowired</code>和<code>@Value</code>的属性，取出之前缓存的该对象InjectionMetadata，调用inject来设置<code>@Autowired</code>依赖属性(期间调用doResolveDependency来获取真正需要注入的属性)。</li><li>doResolveDependency操作详解：<ol><li>先通过findAutowireCandidates方法获取所有的需要注入类型class文件(如果工厂中该对象已经被创建则返回对象)如果查找到的Candidates大于1则使用 determineAutowireCandidate 来进行过滤beanName。</li><li>首先使用determinePrimaryCandidate来查找(对象是否有@Primary注解)</li><li>determineHighestPriorityCandidate来查找(遍历获取这些bean的<code>@Priority</code>的优先级代号(数字越小优先级越高)，返回优先级最高的bean名称。)</li><li>最后遍历所有候选者找出beanName和注入beanName相同的。若有返回该beanName。</li><li>最后根据beanName获取bean对象(相互依赖的情况下会获取早期对象设置)。</li></ol></li><li>applyPropertyValues()</li></ol></li><li>调用initializeBean：<ol><li>如果该类实现了Aware接口(BeanNameAware,BeanClassLoaderAware,BeanFactoryAware)，给该类设置名称，类加载器，工厂等属性。</li><li>applyBeanPostProcessorsBeforeInitialization来执行所有bean后置处理器的postProcessBeforeInitialization。遍历过程中如果有一个处理器返回了null将会终止处理，返回最后处理对象。</li><li>invokeInitMethods执行初始化方法先执行实现InitializingBean接口的afterPropertiesSet方法，之后执行init方法。</li><li>applyBeanPostProcessorsAfterInitialization执行后置处理器postProcessAfterInitialization方法，和2逻辑相同。  </li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>整个bean的创建和初始化过程还是相当繁琐的步骤。bean的整个生命周期还是比较多样的，有很多BeanPostProcessor在bean创建前后以及初始化过程中都对bean进行了管理，包括bean全部创建后还有着回调功能，有着丰富的拓展功能。讲得可能不明了，希望对大家有所帮助。详细的demo可以去看博主的<a href="https://github.com/hiyouka/spring-cloud-resources" title="github" target="_blank" rel="noopener">github</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g0cutps3irj31kw0oy4qp.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在分析spring容器的创建过程中分析了bean的创建过程。由于创建过程步骤还是比较多的于是就新开一篇博客来详细分析下beanFactory的getBean方法做了哪些操作。分析的是通过beanType获取bean，因为根据type获取其实最终调用的也是根据beanName获取bean。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器创建源码解析</title>
    <link href="https://hiyouka.top/spring/ioc-analysis/"/>
    <id>https://hiyouka.top/spring/ioc-analysis/</id>
    <published>2019-01-25T07:17:00.000Z</published>
    <updated>2019-03-25T05:22:10.672Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wkhr0v9j30qo0dc7d2.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;这篇博客是对Spring(5.0.7)的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多，讲的也可能比较枯燥。不过我相信我的分析对大家理解spring容器的整个工作原理还是有一些帮助的。<br><a id="more"></a></p><h3 id="无参构造器："><a href="#无参构造器：" class="headerlink" title="无参构造器："></a>无参构造器：</h3><p>&emsp;&emsp;先是调用它的无参构造函数，初始化一些信息。<br>&emsp;&emsp;无参构造函数中<code>new</code>了<code>AnnotatedBeanDefinitionReader</code>和<code>ClassPathBeanDefiitionScanner</code>赋值给<code>reader</code>context的<code>scanner</code>属性。  </p><h4 id="newAnnotatedBeanDefinitionReader对象："><a href="#newAnnotatedBeanDefinitionReader对象：" class="headerlink" title="newAnnotatedBeanDefinitionReader对象："></a><code>new</code>AnnotatedBeanDefinitionReader对象：</h4><p>&emsp;&emsp;&emsp;&emsp;将该容器对象作为<code>BeanDefinitionRegistry</code>赋值给<code>registry</code>属性,并且<code>new</code>了一个<code>ConditionEvaluator</code>赋值给<code>conditionEvaluator</code>属性。之后调用<code>registerAnnotationConfigProcessors</code>方法将所有的annotation处理器注册进容器。  </p><h5 id="new-ConditionEvaluator"><a href="#new-ConditionEvaluator" class="headerlink" title="new ConditionEvaluator:"></a>new ConditionEvaluator:</h5><p>&emsp;&emsp;&emsp;&emsp;这是spring对该类的描述<code>Internal class used to evaluate {@link Conditional} annotations.</code>。可以看出这个类是<code>@Conditional</code>注解的一个解析器。在创建该类的时候利用<code>deduceBeanFactory</code>给该对象初始化了一个<code>DefaultListableBeanFactory</code>,并且该类是从容器中获取的。  </p><p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wn4k0pjj30ud05u74g.jpg" alt="img"></p><h5 id="AnnotationConfigUtils-registerAnnotationConfigProcessors："><a href="#AnnotationConfigUtils-registerAnnotationConfigProcessors：" class="headerlink" title="AnnotationConfigUtils.registerAnnotationConfigProcessors："></a>AnnotationConfigUtils.registerAnnotationConfigProcessors：</h5><p>&emsp;&emsp;&emsp;&emsp;该方法先是给容器的<code>beanFactory</code>初始化了<code>private Comparator&lt;Object&gt; dependencyComparator;</code>和<code>private AutowireCandidateResolver autowireCandidateResolver</code>两个属性；他们分别是用于bean的排序和解析自动注入<code>@Autowired</code>的；之后便开始注册一些spring内部的bean对象：<br><a name="divtop"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//spring检查容器中是否注入了这些bean 没有就创建简单的含有基本信息的BeanDefiintion对象注册</span></span><br><span class="line">   <span class="comment">// The bean name of the internally managed Configuration annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalConfigurationAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Autowired annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalAutowiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed Required annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalRequiredAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JSR-250 annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalCommonAnnotationProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed JPA annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.annotation.internalPersistenceAnnotationProcessor"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME =</span><br><span class="line"><span class="string">"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed @EventListener annotation processor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_PROCESSOR_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerProcessor"</span>;</span><br><span class="line"><span class="comment">// The bean name of the internally managed EventListenerFactory.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_LISTENER_FACTORY_BEAN_NAME =</span><br><span class="line"><span class="string">"org.springframework.context.event.internalEventListenerFactory"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册过程如下 详见DefaultListableBeanFactory的registerBeanDefinition</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="comment">//do some thing .... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"> <span class="comment">// get beanDefinintion from cache</span></span><br><span class="line">oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="comment">// if cache alredy has this beanName beanDefinition break</span></span><br><span class="line">    <span class="comment">//  some warn message or throw exception</span></span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// determine if create bean has started</span></span><br><span class="line"><span class="comment">//(判断方法很简单benaFactory中的Set&lt;String&gt;alreadyCreated是否已经被填充过)</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123; </span><br><span class="line">           <span class="comment">//lock beanDefinitionMap and put this beanDefinition to map</span></span><br><span class="line">           <span class="comment">//这里有个小细节他在添加元素进beanDefinitionNames时是直接创建了一个原先cache size+1的list</span></span><br><span class="line">           <span class="comment">//然后再将this beanDefinition name 放入list,最终改变beanDefinitionNames的为新创建list</span></span><br><span class="line">           <span class="comment">//if this beanDefinition is in manualSingletonNames,remove from list. why?</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">this.beanDefinitionNames.add(beanName);</span><br><span class="line">this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">this.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 如果这个bean已经存在了单实例的对象则将其销毁</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&emsp;&emsp;至此<code>AnnotatedBeanDefinitionReaderd</code>对象创建完成  </p><h4 id="newClassPathBeanDefinitionScanner对象："><a href="#newClassPathBeanDefinitionScanner对象：" class="headerlink" title="newClassPathBeanDefinitionScanner对象："></a><code>new</code>ClassPathBeanDefinitionScanner对象：</h4><p>&emsp;&emsp;&emsp;&emsp;先是调用这个构造方法：  </p><p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wpn4k0kj30ps07ddg0.jpg" alt="img"><br>&emsp;&emsp;&emsp;&emsp;这里可以看出有3步操作<code>registerDefaultFilters</code>,<code>setEnvironment</code>,<code>setResourceLoader</code>  </p><h5 id="registerDefaultFilters方法"><a href="#registerDefaultFilters方法" class="headerlink" title="registerDefaultFilters方法:"></a>registerDefaultFilters方法:</h5><p>&emsp;&emsp;&emsp;&emsp;从名字我们不难看出这是创建默认过滤器的方法；<br>&emsp;&emsp;&emsp;&emsp;实际上是往该对象中添加了一个匹配<code>@Component</code>注解的AnnotationTypeFilter。spring对该类的解释如下：<br>&emsp;&emsp;&emsp;&emsp;<code>A simple filter which matches classes with a given annotation,checking inherited annotations as well.</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="comment">//代码如下：</span></span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">this.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">((Class&lt;? extends Annotation&gt;) ClassUtils.forName("javax.inject.Named", cl)), false));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="setEnvironment方法"><a href="#setEnvironment方法" class="headerlink" title="setEnvironment方法:"></a>setEnvironment方法:</h5><p>&emsp;&emsp;&emsp;&emsp;一样看名字我们就能知道这是设置环境信息的。就是将之前创建<code>AnnotatedBeanDefinitionReader</code>对象时获取的<code>StandardEnvironment</code>设置给该对象的<code>environment</code>属性。  </p><h5 id="setResourceLoader方法"><a href="#setResourceLoader方法" class="headerlink" title="setResourceLoader方法:"></a>setResourceLoader方法:</h5><p>&emsp;&emsp;&emsp;&emsp;该方法分别给该对象的<code>resourcePatternResolver</code>,<code>metadataReaderFactory</code>,<code>componentsIndex</code>属性初始化。<code>resourcePatternResolver</code>对象其实就是容器对象…. <code>metadataReaderFactory</code>是一个从容器<code>resourceCaches</code>属性拷贝过来的<code>ConcurrentHashMap</code>。<code>resourcePatternResolver</code>可能是在加载<code>META-INF/spring.components</code>这个配置文件吧。具体我也不太清楚。<br>&emsp;&emsp;&emsp;&emsp;<strong>至此spring容器的无参构造函数终于时调用完成了(😓)这只是简单的一步而且很多地方即使是知道了它在干什么还是不清楚他为什么这么做如果有更了解的大佬还望指教</strong>  </p><h3 id="register："><a href="#register：" class="headerlink" title="register："></a>register：</h3><p>&emsp;&emsp;将Config类注册进来，其实就是调用之前创建的<code>AnnotatedBeanDefinitionReader</code>对象的<code>register</code>方法将我们所传入的配置类注册到容器当中。我们可以直接看<code>AnnotatedBeanDefinitionReader</code>对象的<code>doRegisterBean</code>方法：<br>&emsp;&emsp;该方法先是创建了Config对象的定义信息<code>AnnotatedGenericBeanDefinition</code>。之后调用以下方法<code>shouldSkip</code>,<code>resolveScopeMetadata</code>,<code>generateBeanName</code>,<code>processCommonDefinitionAnnotations</code>,<code>applyScopedProxyMode</code>,<code>registerBeanDefinition</code>  </p><p><img src="https://ws1.sinaimg.cn/large/007BVBG7gy1g06wq1o62gj30y00guwfe.jpg" alt="img"></p><h4 id="shouldSkip方法："><a href="#shouldSkip方法：" class="headerlink" title="shouldSkip方法："></a>shouldSkip方法：</h4><p>&emsp;&emsp;&emsp;&emsp;该方法先通过<code>isAnnotated</code>判断有没有<code>@Conditional</code>注解如果有则判断该类是否符合注入要求。<br>&emsp;&emsp;&emsp;&emsp; 我们先来看下他是如何判断有没有该注解的：<br>&emsp;&emsp;&emsp;&emsp;首先是<code>searchWithGetSemantics</code>方法来查出该类所有注解。<code>searchWithGetSemanticsInAnnotations</code>来做判断。如果该注解不是java包中的注解。则判断它是否是<code>@Conditional</code>注解或者任何时候都忽略的process。之后递归调用<code>searchWithGetSemantics</code>来看元注解有没有包含<code>@Conditional</code>的。以下为判断源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">    Class&lt;? extends Annotation&gt; currentAnnotationType = annotation.annotationType();</span><br><span class="line"><span class="keyword">if</span> (!AnnotationUtils.isInJavaLangAnnotationPackage(currentAnnotationType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (currentAnnotationType == annotationType ||</span><br><span class="line">currentAnnotationType.getName().equals(annotationName) ||</span><br><span class="line">processor.alwaysProcesses()) &#123;</span><br><span class="line">T result = processor.process(element, annotation, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (processor.aggregates() &amp;&amp; metaDepth == <span class="number">0</span>) &#123;</span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Repeatable annotations in container?</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currentAnnotationType == containerType) &#123;</span><br><span class="line"><span class="keyword">for</span> (Annotation contained : getRawAnnotationsFromContainer(element, annotation)) &#123;</span><br><span class="line">T result = processor.process(element, contained, metaDepth);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No need to post-process since repeatable annotations within a</span></span><br><span class="line"><span class="comment">// container cannot be composed annotations.</span></span><br><span class="line">processor.getAggregatedResults().add(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="resolveScopeMetadata方法"><a href="#resolveScopeMetadata方法" class="headerlink" title="resolveScopeMetadata方法:"></a>resolveScopeMetadata方法:</h4><p>&emsp;&emsp;&emsp;&emsp;获取该bean的scope(这里就不细讲spring bean的作用域了不懂的自行百度),ScopeMetadata对象的值默认为<code>singleton</code>,所以如果该类没有<code>@Scope</code>注解默认为单例的。  </p><h4 id="generateBeanName方法"><a href="#generateBeanName方法" class="headerlink" title="generateBeanName方法:"></a>generateBeanName方法:</h4><p>&emsp;&emsp;&emsp;&emsp;获取该bean的<code>@Component</code>注解标注的beanName,如果没有默认为类sortName。<br>获取类上的<code>@Component</code>注解步骤与第一步时获取<code>@Conditional</code>注解类似(递归获取注解-排除java注解)这里就不细讲了。</p><h4 id="processCommonDefinitionAnnotations方法"><a href="#processCommonDefinitionAnnotations方法" class="headerlink" title="processCommonDefinitionAnnotations方法:"></a>processCommonDefinitionAnnotations方法:</h4><p> &emsp;&emsp;&emsp;&emsp;对<code>@Lazy</code>,<code>@Primary</code>,<code>@DependsOn</code>,<code>@Role</code>,<code>@Description</code>的解析(这里提一下如果<code>@Lazy</code>没有的话默认是false,之前看到有人说默认懒加载显然时不正确的~)。丰富beanDefinition。比较简单不详细分析了,贴下源码:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">if (lazy != null) &#123;</span><br><span class="line"><span class="code">    abd.setLazyInit(lazy.getBoolean("value"));</span></span><br><span class="line">&#125;</span><br><span class="line">else if (abd.getMetadata() != metadata) &#123;</span><br><span class="line"><span class="code">    lazy = attributesFor(abd.getMetadata(), Lazy.class);</span></span><br><span class="line"><span class="code">    if (lazy != null) &#123;</span></span><br><span class="line"><span class="code">        abd.setLazyInit(lazy.getBoolean("value"));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">if (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line"><span class="code">    abd.setPrimary(true);</span></span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">if (dependsOn != null) &#123;</span><br><span class="line"><span class="code">    abd.setDependsOn(dependsOn.getStringArray("value"));</span></span><br><span class="line">&#125;</span><br><span class="line">if (abd instanceof AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="code">    AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span></span><br><span class="line"><span class="code">    AnnotationAttributes role = attributesFor(metadata, Role.class);</span></span><br><span class="line"><span class="code">    if (role != null) &#123;</span></span><br><span class="line"><span class="code">        absBd.setRole(role.getNumber("value").intValue());</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    AnnotationAttributes description = attributesFor(metadata, Description.class);</span></span><br><span class="line"><span class="code">    if (description != null) &#123;</span></span><br><span class="line"><span class="code">        absBd.setDescription(description.getString("value"));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="applyScopedProxyMode方法"><a href="#applyScopedProxyMode方法" class="headerlink" title="applyScopedProxyMode方法:"></a>applyScopedProxyMode方法:</h4><p>&emsp;&emsp;&emsp;&emsp;判断是否需要创建代理对象。如果需要调用<code>ScopedProxyCreator.createScopedProxy</code>方法创建。(待补全代理对象的创建过程…)  </p><h4 id="registerBeanDefinition方法"><a href="#registerBeanDefinition方法" class="headerlink" title="registerBeanDefinition方法:"></a>registerBeanDefinition方法:</h4><p>&emsp;&emsp;&emsp;&emsp;从方法名可以看出这部是真正的注册beanDefinition。真正调用的是容器中的BeanFactory(这里是<code>DefaultListableBeanFactory</code>)的<code>registerBeanDefinition</code>方法。首先验证beanDefinition的信息(具体我也没看懂在干什么)。之后判断该beanDefinition是否被注册过(若注册过符合条件覆盖之前的beanDefinition)。之后就是第一次注册该bean的操作(和调用无参构造函数注册过程一致<a href="#divtop">详情</a>。)<br>&emsp;&emsp;&emsp;&emsp;  </p><p><strong><code>register</code>方法分析到这里就结束了，其实做的事情就是将配置类注册到容器当中。</strong>  </p><h3 id="refresh："><a href="#refresh：" class="headerlink" title="refresh："></a>refresh：</h3><p>&emsp;&emsp;<code>refresh</code>是最重要的一步，进行了容器刷新以及bean创建。执行步骤比较多。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">prepareRefresh();</span><br><span class="line">// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">// Prepare the bean factory for use in this context.</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line">try &#123;</span><br><span class="line"><span class="code">    // Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="code">    postProcessBeanFactory(beanFactory);</span></span><br><span class="line"><span class="code">    // Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="code">    invokeBeanFactoryPostProcessors(beanFactory);</span></span><br><span class="line"><span class="code">    // Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="code">    registerBeanPostProcessors(beanFactory);</span></span><br><span class="line"><span class="code">    // Initialize message source for this context.</span></span><br><span class="line"><span class="code">    initMessageSource();</span></span><br><span class="line"><span class="code">    // Initialize event multicaster for this context.</span></span><br><span class="line"><span class="code">    initApplicationEventMulticaster();</span></span><br><span class="line"><span class="code">    // Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="code">    onRefresh();</span></span><br><span class="line"><span class="code">    // Check for listener beans and register them.</span></span><br><span class="line"><span class="code">    registerListeners();</span></span><br><span class="line"><span class="code">    // Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="code">    finishBeanFactoryInitialization(beanFactory);</span></span><br><span class="line"><span class="code">    // Last step: publish corresponding event.</span></span><br><span class="line"><span class="code">    finishRefresh();</span></span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line"><span class="code">    // Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line"><span class="code">    destroyBeans();</span></span><br><span class="line"><span class="code">    // Reset 'active' flag.</span></span><br><span class="line"><span class="code">    cancelRefresh(ex);</span></span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line"><span class="code">    // Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="code">    // might not ever need metadata for singleton beans anymore...</span></span><br><span class="line"><span class="code">    resetCommonCaches();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="prepareRefresh-："><a href="#prepareRefresh-：" class="headerlink" title="prepareRefresh()："></a>prepareRefresh()：</h4><p>&emsp;&emsp;&emsp;&emsp; 进行容器的预刷新工作。这步还是比较简单的。先是将容器置为启动状态。之后调用<code>initPropertySources</code>(该方法为空方法，提供给子类的覆盖)<br>最后调用<code>validateRequiredProperties</code>来验证是否包含一些必要参数(这里必要参数依旧为空)。  </p><h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory():"></a>obtainFreshBeanFactory():</h4><p>&emsp;&emsp;&emsp;&emsp; 对<code>beanFactory</code>进行刷新工作。先是调用<code>refreshBeanFactory</code>,使用CAS判断工厂是否已经刷新(已刷新抛异常),之后给工厂bean一个序列化id，<br>并将工厂对象放入缓存(由序列化id映射)。最后返回工厂bean(调用容器无参构造函数创建的<code>DefaultListableBeanFactory</code>对象);  </p><h4 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory):"></a>prepareBeanFactory(beanFactory):</h4><p>进行<code>beanFactory</code>的准备工作:</p><ol><li>给<code>beanFactory</code>添加类加载器，表达式解析器，属性编辑器注册器， <code>ApplicationContextAwareProcessor</code>。</li><li>忽略某些类的自动注入(这些接口大多为Spring为实现类注入bean的功能接口，例如：ApplicationContextAware)。</li><li>指定<code>BeanFactory</code>,<code>ResourceLoader</code>,<code>ApplicationEventPublisher</code>,<code>ApplicationContext</code>这些类型自动注入时的类(除<code>beanFactory</code>为当前<code>beanFactory</code>其余都为当前容器)</li><li>为工厂注入一些环境配置信息(beanName分别为environment、systemProperties、systemEnvironment)</li></ol><h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory:"></a>postProcessBeanFactory:</h4><p>&emsp;&emsp;&emsp;&emsp;该方法时BeanFactory初始化之后再进行后续的一些BeanFactory操作。对于<code>AnnotationConfigApplicationContext</code>这是父类的一个空方法。在SpringBoot创建的另外两个web容器的时候(<code>AnnotationConfigServletWebServerApplicationContext</code>、<code>AnnotationConfigReactiveWebServerApplicationContext</code>)会重写该方法。以后可能会出个SpringBoot原理分析系列详细会讲到这两个容器的创建及准备。</p><h4 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors:"></a>invokeBeanFactoryPostProcessors:</h4><p><code>invokeBeanFactoryPostProcessors</code>方法比较关键。该方法做了以下步骤：</p><ol><li>执行ConfigurationClassPostProcessor,这个处理器主要来解析配置类(分为完整配置类和精简配置类，这里只详解带<code>@Configuration</code>注解的完整配置类)，主要用于注册bean。</li><li>执行其他BeanFactoryPostProcessor。(分为BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor两种接口)</li></ol><h5 id="执行ConfigurationClassPostProcessor："><a href="#执行ConfigurationClassPostProcessor：" class="headerlink" title="执行ConfigurationClassPostProcessor："></a>执行ConfigurationClassPostProcessor：</h5><p> 该方法主要执行了步骤：</p><ol><li><code>ConfigurationClassParser</code>的parse方法：<ol><li>获取<code>@PropertySource</code>注解信息(之后所有的获取注解信息都是分析<code>shouldSkip</code>提到的searchWithGetSemantics方法完成的)，使用processPropertySource解析添加配置文件信息。处理过程大致是先创建PropertySource(创建的时候调用loadProperties读取配置文件信息)。之后将该配置文件信息添加到beanFactory的<code>environment</code>bean对象中去。</li><li>获取<code>@ComponentScans</code>注解信息(若未获取到则为配置类的目录)。使用<code>ComponentScanAnnocationParser</code>来解析需要注册的bean，之后调用<code>ClassPathBeanDefinitionScanner</code>的doScan来将beanDefinition注册进容器。doScan做的事情就是扫包获取指定包的所有class文件并筛选有<code>@Component</code>并且<code>@Conditional</code>匹配的class。BeanDefinition注册过程就是之前提到的registerBeanDefinition方法。之后遍历获取到的BeanDefinitions执行parse。<br>操作将注册进来的Bean里的<code>@PropertySource</code>,<code>@ComponentScans</code>等注解的信息注册进来(递归注册)。</li><li><code>@Import</code>注解解析。processImports方法来执行该操作。将所有该注解引入的类注册到容器当中。使用collectImports方法递归查找该类下所有的注解中包含的<code>@Import</code>引入的对象。之后便是遍历处理操作：<ol><li>如果引入对象是<code>ImportSelector</code>实现类，实例化该类。如果该类实现了<code>Aware</code>接口先给该类初始化这些属性(包含<code>BeanClassLoaderAware</code>,<code>BeanFactoryAware</code>,<code>EnvironmentAware</code>,<code>ResourceLoaderAware</code>)。之后判断如果该类实现类DeferredImportSelector接口就将其放入<code>deferredImportSelectors</code>后续处理。否则调用selectImports获取import对象并执行processImports递归。</li><li>如果引入对象是<code>ImportBeanDefinitionRegistrar</code>实现类，和之前一样先实例化再根据<code>Aware</code>初始化。最后将实例化后的类添加到带有<code>@Import</code>类的<code>ConfigurationClass</code>的<code>importBeanDefinitionRegistrars</code>属性中以便后续操作。</li><li>其他情况将其放入<code>ConfigurationClassParser</code>的<code>importStack</code>的<code>imports</code>缓存(用于判断该类是否需要解析)。生成该类的<code>ConfigurationClass</code>(带有<code>importedBy</code>属性)。</li></ol></li><li><code>@ImportResource</code>和第一步类似这个引入的是spring的配置类。往带有该注解的<code>ConfigurationClass</code>的<code>importedResources</code>属性添加该</li><li><code>retrieveBeanMethodMetadata</code>，解析该类所有带有<code>@Bean</code>的方法将其添加到该类的ConfigurationClass。</li><li><code>processInterfaces</code>，解析注入类中的所有接口中的default方法是否包含<code>@Bean</code>的，如果有就创建一个BeanMethod添加到该类的ConfigurationClass以便下一步来注册该对象。这两个方法查找了所有的<code>@Bean</code>Method。          </li><li>添加父类class到配置类中进行注册操作，和之前的parse操作相同。</li><li>将当前解析类的<code>ConfigurationClass</code>放入<code>ConfigurationClassParser</code>的configurationClasses属性中，为之后解析做准备。</li><li><code>processDeferredImportSelectors</code>处理3中放入<code>deferredImportSelectors</code>缓存中的DeferredImportSelector。调用所有的selectors的selectImports方法来获取所有导入类并封装成<code>SourceClass</code>列表再去调用processImports来递归。(这么多操作实际目的就是将所有的@Import生成<code>ConfigurationClass</code>或者放入<code>importBeanDefinitionRegistrars</code>为之后loadBeanDefinitions做准备)</li></ol></li><li><code>ConfigurationClassBeanDefinitionReader</code>的loadBeanDefinitions：<ol><li>遍历<code>ConfigurationClass</code>执行loadBeanDefinitionsForConfigurationClass。</li><li>判断该<code>ConfigurationClass</code>是否是导入的(带有<code>importedBy</code>属性)，如果是将给类注册到beanFactory</li><li>解析该<code>ConfigurationClass</code>带有<code>@Bean</code>的方法生成beanDefinition(该定义信息除了有Lazy等属性外还有factoryBeanName和factoryMethodName)并注册到容器当中。</li><li>从importedResources属性中注册beanDefinition。读取配置文件信息获取beanDefinition并注册。</li><li>从1.3.2中放入<code>importBeanDefinitionRegistrars</code>属性中调用ImportBeanDefinitionRegistrar的registerBeanDefinitions直接注册到容器中。</li></ol></li></ol><h5 id="执行BeanFactoryPostProcessor："><a href="#执行BeanFactoryPostProcessor：" class="headerlink" title="执行BeanFactoryPostProcessor："></a>执行BeanFactoryPostProcessor：</h5><p>BeanFactoryPostProcessor排序执行：</p><ol><li>获取BeanDefinitionRegistryPostProcessor执行处理(postProcessBeanDefinitionRegistry)。之后执行回调(postProcessBeanFactory)</li><li>获取BeanFactoryPostProcessor执行执行前置处理(postProcessBeanFactory)。之后执行后置处理(postProcessBeanFactory)</li><li>清除beanFactory缓存，清除<code>mergedBeanDefinitions</code>的未创建对象的定义信息。</li></ol><h4 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors:"></a>registerBeanPostProcessors:</h4><p>添加BeanPostProcessors：</p><ol><li>添加BeanPostProcessorChecker处理器。</li><li>获取所有的BeanPostProcessors排序并添加。 registerBeanPostProcessors过程很简单就是将该处理器对象放入beanFactory，这个过程会通过<code>getBean</code>创建处理器对象。</li><li>添加ApplicationListenerDetector处理器。</li></ol><p>执行顺序：</p><ol><li>实现PriorityOrdered接口。</li><li>实现Ordered接口。</li><li>没有实现PriorityOrdered和Ordered接口的。</li><li>实现MergedBeanDefinitionPostProcessor接口的处理器。</li></ol><h4 id="initMessageSource："><a href="#initMessageSource：" class="headerlink" title="initMessageSource："></a>initMessageSource：</h4><p>国际化配置的信息。</p><h4 id="initApplicationEventMulticaster："><a href="#initApplicationEventMulticaster：" class="headerlink" title="initApplicationEventMulticaster："></a>initApplicationEventMulticaster：</h4><p>初始化容器的事件广播器。如果容器中没有<code>applicationEventMulticaster</code>bean对象，创建一个SimpleApplicationEventMulticaster时间广播器并注册进beanFactory。</p><h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh:"></a>onRefresh:</h4><p>可以重写的模板方法，以添加特定于上下文的刷新工作。对于AnnotationConfigApplicationContext这是个空方法。</p><h4 id="registerListeners："><a href="#registerListeners：" class="headerlink" title="registerListeners："></a>registerListeners：</h4><p>检查监听器bean并注册它们：</p><ol><li>注册静态指定的侦听器。(添加到applicationListeners集合中)</li><li>从beanFactory获取ApplicationListener类型的beanNames并注册他们。</li><li>执行早期容器事件。</li></ol><h4 id="finishBeanFactoryInitialization："><a href="#finishBeanFactoryInitialization：" class="headerlink" title="finishBeanFactoryInitialization："></a>finishBeanFactoryInitialization：</h4><p>将实例化的beanDefinition进行实例化：</p><ol><li>如果容器中没有字符串解析器，new字符串解析器(使用容器Environment中的解析器来解析,默认是PropertySourcesPropertyResolver)。</li><li>开启允许缓存所有的beanDefinition并且将所有的beanDefinitions放入冻结配置情况的缓存中。</li><li>使用beanFactory的<code>preInstantiateSingletons</code>来实例化所有的beanDefinition。<ol><li>遍历所有beanDefinition，获取该bean组合的beanDefinition。如果该bean需要工厂创建的对象，先使用getBean获取工厂对象再getBean获取工产对象。不是工厂对象直接调用getBean。(getBean起到创建对象作用。创建对象时会调用BeanPostProcessor。详细看<a href="https://hiyouka.top/spring/getBean/">这篇博客</a>这篇博客)</li><li>遍历所有的beanDefinition，getSingleton从缓存中获取之前创建的Bean。如果该bean实现了SmartInitializingSingleton接口，执行接口方法afterSingletonsInstantiated。</li></ol></li></ol><h4 id="finishRefresh："><a href="#finishRefresh：" class="headerlink" title="finishRefresh："></a>finishRefresh：</h4><ol><li>清除上下文级资源缓存（这里是资源reader对象）。</li><li>为此上下文初始化生命周期处理器。（beanName：lifecycleProcessor），如果没有获取到默认注册DefaultLifecycleProcessor。</li><li>调用生命周期处理器的onRefresh：<ol><li>获取beanFactory中所有实现Lifecycle接口的beanName，遍历，筛选出实现Lifecycle接口的必须在之前被实例化了或者实现SmartLifecycle接口。（过滤lifecycleProcessor）</li><li>遍历1获取的所有Lifecycle中实现SmartLifecycle接口并且该类的isAutoStartup方法为true的对象。</li><li>遍历2中获取的Lifecycle执行start方法。</li></ol></li><li>添加ContextRefreshedEvent的</li><li>向LiveBeansView中注册该容器。（JMX的相关操作）</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>以上就是AnnotationConfigApplicationContext的创建过程。这里解析的都是基于注解的解析方式，由兴趣的小伙伴还可以看下基于xml的解析(应该只有Resource读取有所差异)，之后我会自己实现一个可以扩展的简单容器（项目名字已经起好了叫seed😁），应该还会整合这个容器和netty（还在学习中…）实现一个异步的Controller层的框架，希望我的文章能帮到大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/007BVBG7gy1g06wkhr0v9j30qo0dc7d2.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这篇博客是对Spring(5.0.7)的ioc容器创建过程的解析，也是博主不断debug几天的成果。内容可能有点多，讲的也可能比较枯燥。不过我相信我的分析对大家理解spring容器的整个工作原理还是有一些帮助的。&lt;br&gt;
    
    </summary>
    
      <category term="spring实现" scheme="https://hiyouka.top/categories/spring%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="ioc" scheme="https://hiyouka.top/tags/ioc/"/>
    
      <category term="spring" scheme="https://hiyouka.top/tags/spring/"/>
    
  </entry>
  
</feed>
